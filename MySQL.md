# MySQL

[图解mysql](https://xiaolincoding.com/mysql/)

[mysql源码](https://www.iskm.org/mysql56/index.html)

# 数据查询过程

- 连接器：建立连接，管理连接、校验用户身份；
- 查询缓存：查询语句如果命中查询缓存则直接返回，否则继续往下执行。MySQL 8.0 已删除该模块；
- 解析 SQL，通过解析器对 SQL 查询语句进行词法分析、语法分析，然后构建语法树，方便后续模块读取表名、字段、语句类型；
- 执行 SQL：执行 SQL 共有三个阶段：
  - 预处理阶段：检查表或字段是否存在；将 `select *` 中的 `*` 符号扩展为表上的所有列。
  - 优化阶段：基于查询成本的考虑， 选择查询成本最小的执行计划；
  - 执行阶段：根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端；

![查询语句执行流程](./img/MySQL/mysql查询流程.png)

## 连接

- 与客户端进行 TCP 三次握手建立连接；
- 校验客户端的用户名和密码，如果用户名或密码不对，则会报错；
- 如果用户名和密码都对了，会读取该用户的权限，然后后面的权限逻辑判断都基于此时读取到的权限；



**最大空闲时长**：MySQL 定义了空闲连接的**最大空闲时长**，由 `wait_timeout` 参数控制的，默认值是 8 小时（28880秒），如果空闲连接超过了这个时间，连接器就会自动将它断开。

**连接数限制**：MySQL 服务支持的最大连接数由 max_connections 参数控制，超过这个值系统就会拒绝接下来的连接请求，并报错提示“Too many connections”。

**短连接和长连接**

```c
// 短连接
连接 mysql 服务（TCP 三次握手）
执行sql
断开 mysql 服务（TCP 四次挥手）

// 长连接
连接 mysql 服务（TCP 三次握手）
执行sql
执行sql
执行sql
....
断开 mysql 服务（TCP 四次挥手）
```

使用长连接的好处就是可以减少建立连接和断开连接的过程，所以一般是推荐使用长连接。

但是，使用长连接后可能会占用内存增多，因为 MySQL 在执行查询过程中临时使用内存管理连接对象，这些连接对象资源只有在连接断开时才会释放。如果长连接累计很多，将导致 MySQL 服务占用内存太大，有可能会被系统强制杀掉，这样会发生 MySQL 服务异常重启的现象。



**Q&A**

如何查看mysl 被多少客户端链接了

`show processlist`

![image-20230804154950897](./img/MySQL/image-20230804154950897.png)

怎么解决长连接占用内存的问题？

第一种，**定期断开长连接**。既然断开连接后就会释放连接占用的内存资源，那么我们可以定期断开长连接。

第二种，**客户端主动重置连接**。MySQL 5.7 版本实现了 `mysql_reset_connection()` 函数的接口，注意这是接口函数不是命令，那么当客户端执行了一个很大的操作后，在代码里调用 mysql_reset_connection 函数来重置连接，达到释放内存的效果。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。



## 查询缓存(Query Cache)

查询语句会先查询 查询缓存(Query Cache )，key-value 结构 key 为 SQL，value 为结果。

如果表有更新操作，查询缓存会被清空。

MySQL 8.0及之后版本已经删除了查询缓存。

对于 MySQL 8.0 之前的版本，如果想关闭查询缓存，我们可以通过将参数 query_cache_type 设置成 `DEMAND`。

查询缓存是server 层的，并不是 Innodb 存储引擎中的 buffer pool

## 解析

解析器会做如下两件事情。

**词法分析**。MySQL 会根据你输入的字符串识别出关键字出来，构建出 SQL 语法树，这样方便后面模块获取 SQL 类型、表名、字段名、 where 条件等等。

**语法分析**。根据词法分析的结果，语法解析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法。

如果我们输入的 SQL 语句语法不对，就会在解析器这个阶段报错。比如，我下面这条查询语句，把 from 写成了 form，这时 MySQL 解析器就会给报错。

表不存在或者字段不存在，并不是在解析器里做的。解析器只负责构建语法树和检查语法，但是不会去查表或者字段存不存在。

## 执行

三个阶段

- prepare 阶段，预处理阶段；
- optimize 阶段，优化阶段；
- execute 阶段，执行阶段；

###  预处理器

- 检查 SQL 查询语句中的表或者字段是否存在；
- 将 `select *` 中的 `*` 符号，扩展为表上的所有列；

###  优化器

**优化器主要负责将 SQL 查询语句的执行方案确定下来**，比如在表里面有多个索引的时候，优化器会基于查询成本的考虑，来决定选择使用哪个索引。

以在查询语句最前面加个 `explain` 命令，这样就会输出这条 SQL 语句的执行计划，然后执行计划中的 key 就表示执行过程中使用了哪个索引。

索引后面再讲

###  执行器

三种方式执行过程

**主键索引查询**

```sql
select * from product where id = 1;
```

- 执行器第一次查询，会调用 read_first_record 函数指针指向的函数，因为优化器选择的访问类型为 const，这个函数指针被指向为 InnoDB 引擎索引查询的接口，把条件 `id = 1` 交给存储引擎，**让存储引擎定位符合条件的第一条记录**。
- 存储引擎通过主键索引的 B+ 树结构定位到 id = 1的第一条记录，如果记录是不存在的，就会向执行器上报记录找不到的错误，然后查询结束。如果记录是存在的，就会将记录返回给执行器；
- 执行器从存储引擎读到记录后，接着判断记录是否符合查询条件，如果符合则发送给客户端，如果不符合则跳过该记录。
- 执行器查询的过程是一个 while 循环，所以还会再查一次，但是这次因为不是第一次查询了，所以会调用 read_record 函数指针指向的函数，因为优化器选择的访问类型为 const，这个函数指针被指向为一个永远返回 - 1 的函数，所以当调用该函数的时候，执行器就退出循环，也就是结束查询了。



**全表扫描**

```sql
select * from product where name = 'iphone';
```

- 执行器第一次查询，会调用 read_first_record 函数指针指向的函数，因为优化器选择的访问类型为 all，这个函数指针被指向为 InnoDB 引擎全扫描的接口，**让存储引擎读取表中的第一条记录**；
- 执行器会判断读到的这条记录的 name 是不是 iphone，如果不是则跳过；如果是则将记录发给客户端。Server 层每从存储引擎读到一条记录就会发送给客户端。客户端等查询语句查询完成后，才会显示出所有的记录
- 一直重复上述过程，直到存储引擎把表中的所有记录读完，然后向执行器（Server层） 返回了读取完毕的信息；
- 执行器收到存储引擎报告的查询完毕的信息，退出循环，停止查询。





**索引下推 (index condition pushdown)**

MySQL 5.6 推出的查询优化策略

```sql
# idx_age_reward
select * from t_user  where age > 20 and reward = 100000;
```

不使用索引下推执行器与存储引擎的执行流程：

- 定位到最左匹配的第一条记录， age > 20 的第一条记录。
- 获取所有满足最左匹配的数据，拿出主键，然后进行回表，再把完整的记录返回给 Server 层，Server判断reward是否满足条件，否则跳过。
- 重复操作，直到存储引擎把表中的所有符合条件的记录读完。

使用索引下推执行器与存储引擎的执行流程：

- 定位到最左匹配的第一条记录， age > 20 的第一条记录。
- 获取所有满足最左匹配的数据，判断reward是否满足条件，如果不成立则抛弃，如果成立则回表，将记录返回给 Server 层。
- 重复操作，直到存储引擎把表中的所有符合条件的记录读完。



当组合索引满足最左匹配，但是遇到非等值判断时匹配停止。进行索引下推，由存储引擎过滤剩下的组合索引条件，减少回表数据。



# 数据存储格式

文件存放目录

```mysql
mysql> SHOW VARIABLES LIKE 'datadir';
+---------------+-----------------+
| Variable_name | Value           |
+---------------+-----------------+
| datadir       | /var/lib/mysql/ |
+---------------+-----------------+
1 row in set (0.00 sec)
```

```bash
[root@root ~]#ls /var/lib/mysql/my_test
db.opt  
t_order.frm  
t_order.ibd
```

- db.opt，用来存储当前数据库的默认字符集和字符校验规则。
- t_order.frm ，t_order 的**表结构**。
- t_order.ibd，t_order 的**表数据**会保存在这个文件。表数据既可以存在共享表空间文件（文件名：ibdata1）里，也可以存放在独占表空间文件（文件名：表名字.ibd）。这个行为是由参数 innodb_file_per_table 控制的，若设置了参数 innodb_file_per_table 为 1，则会将存储的数据、索引等信息单独存储在一个独占表空间，从 MySQL 5.6.6 版本开始，它的默认值就是 1 了，因此从这个版本之后， MySQL 中每一张表的数据都存放在一个独立的 .ibd 文件。

## 表空间文件的结构

**表空间由段（segment）、区（extent）、页（page）、行（row）组成**，InnoDB存储引擎的逻辑存储结构大致如下图：

![img](./img/MySQL/表空间结构.drawio.png)

**行（row）**

数据库表中的记录都是按行（row）进行存放的，每行记录根据不同的行格式，有不同的存储结构。

**页（page）**

innoDB 的数据是按「页」为单位来读写的。
**默认每个页的大小为 16KB**，最多能保证 16KB 的连续存储空间。
页是 InnoDB 存储引擎磁盘管理的最小单元，意味着数据库每次读写都是以 16KB 为单位的，一次最少从磁盘中读取 16K 的内容到内存中，一次最少把内存中的 16K 内容刷新到磁盘中。

一行的字节大小不能超过数据页的大小，当一行的字节大小超过数据页的大小时，这个行就无法存储在单个数据页中，这被称为行溢出（**row overflow**）。

页的类型有很多，常见的有数据页、undo 日志页、溢出页等等。数据表中的行记录是用「数据页」来管理的。

**区（extent）**

区是一组连续「页」的集合。

每个区的大小通常是多个数据页的大小的倍数，这个倍数可以根据具体的配置进行设置。例如，在InnoDB存储引擎中，默认情况下，一个区的大小为1MB，而一个数据页的大小为16KB。因此，一个区包含64个数据页。

区的主要目的是减少磁盘IO操作的次数。当MySQL需要分配新的存储空间来存储数据时，它会以区为单位进行分配。这样，相对于每次只分配一个数据页，分配一个区可以减少磁盘IO操作的次数，提高性能。

区还有助于提高数据的连续性。由于区是一组连续的数据页，当数据被存储在区中时，它们在磁盘上的物理位置也是连续的。这有助于提高数据的访问效率，减少磁盘寻道的开销。

**段（segment）**

表空间是由各个段（segment）组成的，段是由多个区（extent）组成的。段一般分为数据段、索引段和回滚段等。

- 索引段：存放 B + 树的非叶子节点的区的集合；
- 数据段：存放 B + 树的叶子节点的区的集合；
- 回滚段：存放的是回滚数据的区的集合；

## 行格式(row_format)

行格式（row_format），就是一条记录的存储结构。

InnoDB 提供了 4 种行格式，分别是 Redundant、Compact、Dynamic和 Compressed 行格式。

- Redundant 是很古老的行格式了， MySQL 5.0 版本之前用的行格式，现在基本没人用了。
- Compact 是一种紧凑的行格式，设计的初衷就是为了让一个数据页中可以存放更多的行记录，从 MySQL 5.1 版本之后，行格式默认设置成 Compact。
- Dynamic 和 Compressed 两个都是紧凑的行格式，它们的行格式都和 Compact 差不多，因为都是基于 Compact 改进一点东西。从 MySQL5.7 版本之后，默认使用 Dynamic 行格式。



**COMPACT 行格式**

![img](./img/MySQL/COMPACT.drawio.png)

```sql
CREATE TABLE `t_user` (
  `id` int(11) NOT NULL,
  `name` VARCHAR(20) DEFAULT NULL,
  `phone` VARCHAR(20) DEFAULT NULL,
  `age` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB DEFAULT CHARACTER SET = ascii ROW_FORMAT = COMPACT;
```

一条完整的记录分为「记录的额外信息」和「记录的真实数据」两个部分

### 记录的额外信息

1. **变长字段长度列表**
   变长字段的真实数据占用的字节数
   如果是NULL，则不会保存变长字段的长度
   如果没有变长之短，则不会有变长字段长度列表
2. **NULL值列表**
   记录真实值为NULL的值
   如果存在允许 NULL 值的列，则每个列对应一个二进制位（bit），二进制位按照列的顺序逆序排列。
   如果一个字节存不下NULL值列表，则会扩增到两个字节。
   当所有字段都是NOT NULL，则不会有NULL值列表。
3. **记录头信息**
   这几个比较重要
   **delete_mask** ：标识此条数据是否被删除。从这里可以知道，我们执行 detele 删除记录的时候，并不会真正的删除记录，只是将这个记录的 delete_mask 标记为 1。
   **next_record**：下一条记录的位置。指向的是下一条记录的「记录头信息」和「真实数据」之间的位置，这样的好处是向左读就是记录头信息，向右读就是真实数据，比较方便。
   **record_type**：表示当前记录的类型，0表示普通记录，1表示B+树非叶子节点记录，2表示最小记录，3表示最大记录

额外信息大部分都是**逆序**存放。这样的好处是向左读就是记录头信息，向右读就是真实数据

### 记录的真实数据

记录真实数据部分除了我们定义的字段，还有三个隐藏字段，分别为：row_id、trx_id、roll_pointer

- row_id

如果我们建表的时候指定了主键或者唯一约束列，那么就没有 row_id 隐藏字段了。如果既没有指定主键，又没有唯一约束，那么 InnoDB 就会为记录添加 row_id 隐藏字段。row_id不是必需的，占用 6 个字节。

- trx_id

事务id，表示这个数据是由哪个事务生成的。 trx_id是必需的，占用 6 个字节。

- roll_pointer

这条记录上一个版本的指针。roll_pointer 是必需的，占用 7 个字节。

### 行溢出(row overflow)

默认的数据页大小是16KB，一行的字节大小不能超过数据页的大小，当一行的字节大小超过数据页的大小时，这个行就无法存储在单个数据页中，这被称为行溢出（**row overflow**）。

为了处理行溢出的情况，MySQL提供了一种机制，即将溢出的数据存储在额外的数据页中，并通过指针进行引用。但是，这种行溢出的处理会增加额外的存储和访问成本，并且可能影响查询性能。

为了避免行溢出的情况，MySQL限制了一行的字节大小不能超过数据页的大小。对于InnoDB存储引擎，默认情况下，一行的字节大小不能超过65535个字节（64KB - 1）。

一些大对象如 TEXT、BLOB 可能存储更多的数据，这时一个页可能就存不了一条记录。这个时候就会**发生行溢出，多的数据就会存到另外的「溢出页」中**。

Compact 行格式发生行溢出时，在记录的真实数据处只会保存该列的一部分数据，而把剩余的数据放在「溢出页」中，然后真实数据处用 20 字节存储指向溢出页的地址，从而可以找到剩余数据所在的页。大致如下图所示。

Compressed 和 Dynamic 行格式发生行溢出时，只存储 20 个字节的指针来指向溢出页，而实际的数据都存储在溢出页中。



# 索引

索引的定义就是帮助存储引擎快速获取数据的一种数据结构，索引是数据的目录。

## 索引的分类

- 按「数据结构」分类：**B+tree索引、Hash索引、Full-text索引**。
- 按「物理存储」分类：**聚簇索引（主键索引）、二级索引（辅助索引）**。
- 按「字段特性」分类：**主键索引、唯一索引、普通索引、前缀索引**。
- 按「字段个数」分类：**单列索引、联合索引**。



**1.按数据结构分类**

从数据结构的角度来看，MySQL 常见索引有 B+Tree 索引、HASH 索引、Full-Text 索引。

| 索引类型  | InnoDB                                     | MyISAM | Memory |
| --------- | ------------------------------------------ | ------ | ------ |
| B+Tree    | yes                                        | yes    | yes    |
| HASH      | no(但是在内存结构中有一个自适应的hash索引) | no     | yes    |
| Full-Text | yes                                        | yes    | no     |

InnoDB 是在 MySQL 5.5 之后成为默认的 MySQL 存储引擎，B+Tree 索引类型也是 MySQL 存储引擎采用最多的索引类型。

在创建表时，InnoDB 存储引擎会根据不同的场景选择不同的列作为索引：

- 如果有主键，默认会使用主键作为聚簇索引的索引键（key）；
- 如果没有主键，就选择第一个不包含 NULL 值的唯一列作为聚簇索引的索引键（key）；
- 在上面两个都没有的情况下，InnoDB 将自动生成一个隐式自增 id 列作为聚簇索引的索引键（key）；

除主键索引外，其它索引都属于辅助索引（Secondary Index），也被称为二级索引或非聚簇索引。
**创建的主键索引和二级索引默认使用的是 B+Tree 索引**。

![主键索引 B+Tree](./img/MySQL/btree.drawio.png)



**2.按物理存储分类**

从物理存储的角度来看，索引分为聚簇索引（主键索引）、二级索引（辅助索引）。

- 主键索引的 B+Tree 的叶子节点存放的是实际数据，所有完整的用户记录都存放在主键索引的 B+Tree 的叶子节点里；
- 二级索引的 B+Tree 的叶子节点存放的是主键值，而不是实际数据。

所以，在查询时使用了二级索引，如果查询的数据能在二级索引里查询的到，那么就不需要回表，这个过程就是**覆盖索引**。
如果查询的数据不在二级索引里，就会先检索二级索引，找到对应的叶子节点，获取到主键值后，然后再检索主键索引，就能查询到数据了，这个过程就是**回表**。

**3.按照字段特性分类**

从字段特性的角度来看，索引分为主键索引、唯一索引、普通索引、前缀索引。

**主键索引**就是建立在主键字段上的索引，通常在创建表的时候一起创建，一张表最多只有一个主键索引，索引列的值不允许有空值。

**唯一索引**建立在 UNIQUE 字段上的索引，一张表可以有多个唯一索引，索引列的值必须唯一，但是允许有空值。

**普通索引**就是建立在普通字段上的索引，既不要求字段为主键，也不要求字段为 UNIQUE。

**前缀索引**是指对字符类型字段的前几个字符建立的索引，而不是在整个字段上建立的索引，前缀索引可以建立在字段类型为 char、 varchar、binary、varbinary 的列上。使用前缀索引的目的是为了减少索引占用的存储空间，提升查询效率。



**4.按字段个数分类**

从字段个数的角度来看，索引分为单列索引、联合索引（复合索引）。



通过将多个字段组合成一个索引，该索引就被称为**联合索引**。

![联合索引](./img/MySQL/联合索引.drawio.png)



## 索引的查询过程





**1.通过主键查询**

B+Tree 会自顶向下逐层进行查找

数据库的索引和数据都是存储在硬盘的，我们可以把读取一个节点当作一次磁盘 I/O 操作。那么上面的整个查询过程一共经历了 3 个节点，也就是进行了 3 次 I/O 操作。

B+Tree 存储千万级的数据只需要 3-4 层高度就可以满足，这意味着从千万级的表查询目标数据最多需要 3-4 次磁盘 I/O，所以**B+Tree 相比于 B 树和二叉树来说，最大的优势在于查询效率很高，因为即使在数据量很大的情况，查询一个数据的磁盘 I/O 依然维持在 3-4次。**



**2.通过二级索引查询**

主键索引的 B+Tree 和二级索引的 B+Tree 区别如下：

- 主键索引的 B+Tree 的叶子节点存放的是实际数据，所有完整的用户记录都存放在主键索引的 B+Tree 的叶子节点里；
- 二级索引的 B+Tree 的叶子节点存放的是主键值，而不是实际数据。

会先检二级索引中的 B+Tree 的索引值，找到对应的叶子节点，然后获取主键值，然后再通过主键索引中的 B+Tree 树查询到对应的叶子节点，然后获取整行数据。**这个过程叫「回表」，也就是说要查两个 B+Tree 才能查到数据**。

当查询的数据是能在二级索引的 B+Tree 的叶子节点里查询到，这时就不用再查主键索引查。**这种在二级索引的 B+Tree 就能查询到结果的过程就叫作「覆盖索引」，也就是只需要查一个 B+Tree 就能找到数据**。

**3.联合索引查询**

联合索引的非叶子节点用两个字段的值作为 B+Tree 的 key 值。当在联合索引查询数据时，先按第一个字段比较，在第一个相同的情况下再按第二个字段比较。

使用联合索引时，存在**最左匹配原则**，也就是按照最左优先的方式进行索引的匹配。在使用联合索引进行查询的时候，如果不遵循「最左匹配原则」，联合索引会失效，这样就无法利用到索引快速查询的特性了。

**利用索引的前提是索引里的 key 是有序的**。



**4.联合索引范围查询**

可能存在部分字段用到联合索引的 B+Tree，部分字段没有用到联合索引的 B+Tree 的情况。

联合索引的最左匹配原则，在遇到范围查询的时候，就会停止匹配，也就是范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引。注意，对于 >=、<=、BETWEEN、like 前缀匹配的范围查询，并不会停止匹配.

**5.联合索引排序**

使用了联合索引，进行排序可能会 filesort // TODO 整理过一个文档，改天找找

利用索引的有序性，筛选完了之后是排序好的，避免filesort 提高效率

**5.索引下推**

可以在联合索引遍历过程中，对联合索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。

当查询语句的执行计划里，出现了 Extra 为 `Using index condition`，那么说明使用了索引下推的优化。



## 查询EXPLAIN

```mysql
EXPLAIN select * from t_user where id +1 = 10;
```

![img](./img/MySQL/798ab1331d1d6dff026e262e788f1a28.png)

- possible_keys 字段表示可能用到的索引；
- key 字段表示实际用的索引，如果这一项为 NULL，说明没有使用索引；
- key_len 表示索引的长度；
- rows 表示扫描的数据行数。
- type 表示数据扫描类型。



type 字段有，常见扫描类型的**执行效率从低到高的顺序为**：

- All（全表扫描）；
- index（全索引扫描）；
- range（索引范围扫描）只检索给定范围的行，属于范围查找。
- ref（非唯一索引扫描）是使用了非唯一索引或者是唯一索引的非唯一性前缀，返回数据返回可能是多条。
- eq_ref（唯一索引扫描）是使用主键或唯一索引时产生的访问方式。
- const（结果只有一条的主键或唯一索引扫描）是使用了主键或者唯一索引与常量值进行比较。

extra字段，比较重要的有

- Using filesort ：当查询语句中包含 group by 操作，而且无法利用索引完成排序操作的时候， 这时不得不选择相应的排序算法进行，甚至可能会通过文件排序，效率是很低的，所以要避免这种问题的出现。
- Using temporary：使了用临时表保存中间结果，MySQL 在对查询结果排序时使用临时表，常见于排序 order by 和分组查询 group by。效率低，要避免这种问题的出现。
- Using index：所需数据只需在索引即可全部获得，不须要再到表中取数据，也就是使用了覆盖索引，避免了回表操作，效率不错。



## 索引失效

**1. 索引区分度**

```
区分度 = distinct(column) / count(*) 
```

查询优化器发现某个值出现在表的数据行中的百分比（惯用的百分比界线是"30%"）很高的时候，它一般会忽略索引，进行全表扫描

**2.索引被计算**
左或者左右模糊匹配
在查询条件中对索引列做了计算、函数、类型转换操作

**3.没命中索引**
WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。

等等

## 索引面试题

**1.为什么单表不要超过2000w行？**

非叶子节点内指向其他页的数量为 x，索引页数据大小约为15k,索引页一条数据大概为12byte，x=15\*1024/12≈1280 行
叶子节点内能容纳的数据行数为 y，叶子页数据大小约为15k,假设一行数据1k, Y = 15\*1024/1000 ≈15行
B+ 数的层数为 z
Total =x^(z-1) \*y

如果z = 2，Total = （1280 ^1 ）*15 = 19200
如果z = 3，Total = （1280 ^2） *15 = 24576000 （约 2.45kw）

如果叶子节点内一行数据15k，则Y = 1
如果z = 2，Y = 1 ,Total = （1280 ^1 ）*1 = 1280
如果z = 3，Y = 1, Total = （1280 ^2） *1 = 1638400 （约 1百万）

所以，在保持相同的层级（相似查询性能）的情况下，在行数据大小不同的情况下，其实这个最大建议值也是不同的，而且影响查询性能的还有很多其他因素，比如，数据库版本，服务器配置，sql 的编写等等。

当单表数据库到达某个量级的上限时，导致内存无法存储其索引，使得之后的 SQL 查询会产生磁盘 IO，从而导致性能下降，所以增加硬件配置（比如把内存当磁盘使），可能会带来立竿见影的性能提升哈。



# 事务

- **原子性（Atomicity）**：一个事务中的所有操作，要么全部完成，要么全部不完成。
- **一致性（Consistency）**：是指事务操作前和操作后，数据满足完整性约束。
- **隔离性（Isolation）**：多个并发事务相互操作是隔离的。
- **持久性（Durability）**：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。



 MyISAM 引擎不支持事务

InnoDB 引擎通过以下技术来保证事务的这四个特性

- 原子性（Atomicity）是通过 undo log（回滚日志） 在事务执行期间，将所有修改操作记录到日志中，如果事务失败或回滚，可以使用undo log将数据恢复到事务开始之前的状态。
- 一致性（Consistency） 通过redo log（重做日志）来保证事务的一致性。redo log已经记录了事务的所有修改操作，所以在数据库重启后，可以通过redo log来恢复事务，保证数据的一致性。
- 隔离性（Isolation）：使用了MVCC（多版本并发控制）来保证事务的隔离性。通过为每个读取操作创建一个“快照”，MVCC允许多个事务同时读取同一行数据，而不会互相干扰。同时，InnoDB还提供了四种事务隔离级别，分别是READ UNCOMMITTED（读未提交）、READ COMMITTED（读已提交）、REPEATABLE READ（可重复读）和SERIALIZABLE（串行化），用户可以根据需要选择合适的隔离级别。
- 持久性（Durability）：InnoDB引擎通过将redo log持久化到磁盘来保证事务的持久性。每当事务提交时，InnoDB都会先将redo log写入磁盘，然后再将事务的状态标记为“已提交”。这样即使在事务提交后数据库立即崩溃，也可以在数据库重启后通过redo log来恢复事务，保证数据的持久性。



**脏读（dirty read）**:读到其他事务未提交的数据。

**不可重复读（non-repeatable read）**：前后读取的数据不一致。

**幻读（phantom read）**：前后读取的记录数量不一致。

## 事务的隔离级别

- **读未提交（read uncommitted）**，指一个事务还没提交时，它做的变更就能被其他事务看到；
- **读提交（read committed）**，指一个事务提交之后，它做的变更才能被其他事务看到；
- **可重复读（repeatable read）**，指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，**MySQL InnoDB 引擎的默认隔离级别**；
- **串行化（serializable）**；会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行；



**实现方式：**

读未提交：直接读取最新的数据就好了

读提交：每个语句执行前生成Read View

可重复读：启动事务时，生成Read View，整个事务期间都用这个Read View

串行化：加读写锁的方式来避免并行访问



**Read View 在MVCC里面怎么工作**

// TODO

简单来说

当一个事务需要读取一条记录时，InnoDB会检查该记录的版本信息（每条记录都有对应的版本信息，包括创建该版本的事务ID，以及删除（如果被删除的话）该版本的事务ID），然后根据Read View的信息来决定是否可以看到该记录：

1. 如果记录的创建事务ID在Read View的活跃事务列表中，那么这个记录对当前事务是不可见的，因为这个记录是在当前事务开始后才创建的。
2. 如果记录的创建事务ID不在Read View的活跃事务列表中，但是删除事务ID在活跃事务列表中，那么这个记录对当前事务也是不可见的，因为这个记录在当前事务开始后被其他事务删除了。
3. 如果记录的创建事务ID和删除事务ID都不在Read View的活跃事务列表中，那么这个记录对当前事务是可见的。
