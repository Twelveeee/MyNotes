# MySQL

[图解mysql](https://xiaolincoding.com/mysql/)

[mysql源码](https://www.iskm.org/mysql56/index.html)

# 数据查询过程

- 连接器：建立连接，管理连接、校验用户身份；
- 查询缓存：查询语句如果命中查询缓存则直接返回，否则继续往下执行。MySQL 8.0 已删除该模块；
- 解析 SQL，通过解析器对 SQL 查询语句进行词法分析、语法分析，然后构建语法树，方便后续模块读取表名、字段、语句类型；
- 执行 SQL：执行 SQL 共有三个阶段：
  - 预处理阶段：检查表或字段是否存在；将 `select *` 中的 `*` 符号扩展为表上的所有列。
  - 优化阶段：基于查询成本的考虑， 选择查询成本最小的执行计划；
  - 执行阶段：根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端；

![查询语句执行流程](./img/MySQL/mysql查询流程.png)

## 连接

- 与客户端进行 TCP 三次握手建立连接；
- 校验客户端的用户名和密码，如果用户名或密码不对，则会报错；
- 如果用户名和密码都对了，会读取该用户的权限，然后后面的权限逻辑判断都基于此时读取到的权限；



**最大空闲时长**：MySQL 定义了空闲连接的**最大空闲时长**，由 `wait_timeout` 参数控制的，默认值是 8 小时（28880秒），如果空闲连接超过了这个时间，连接器就会自动将它断开。

**连接数限制**：MySQL 服务支持的最大连接数由 max_connections 参数控制，超过这个值系统就会拒绝接下来的连接请求，并报错提示“Too many connections”。

**短连接和长连接**

```c
// 短连接
连接 mysql 服务（TCP 三次握手）
执行sql
断开 mysql 服务（TCP 四次挥手）

// 长连接
连接 mysql 服务（TCP 三次握手）
执行sql
执行sql
执行sql
....
断开 mysql 服务（TCP 四次挥手）
```

使用长连接的好处就是可以减少建立连接和断开连接的过程，所以一般是推荐使用长连接。

但是，使用长连接后可能会占用内存增多，因为 MySQL 在执行查询过程中临时使用内存管理连接对象，这些连接对象资源只有在连接断开时才会释放。如果长连接累计很多，将导致 MySQL 服务占用内存太大，有可能会被系统强制杀掉，这样会发生 MySQL 服务异常重启的现象。



**Q&A**

如何查看mysl 被多少客户端链接了

`show processlist`

![image-20230804154950897](./img/MySQL/image-20230804154950897.png)

怎么解决长连接占用内存的问题？

第一种，**定期断开长连接**。既然断开连接后就会释放连接占用的内存资源，那么我们可以定期断开长连接。

第二种，**客户端主动重置连接**。MySQL 5.7 版本实现了 `mysql_reset_connection()` 函数的接口，注意这是接口函数不是命令，那么当客户端执行了一个很大的操作后，在代码里调用 mysql_reset_connection 函数来重置连接，达到释放内存的效果。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。



## 查询缓存(Query Cache)

查询语句会先查询 查询缓存(Query Cache )，key-value 结构 key 为 SQL，value 为结果。

如果表有更新操作，查询缓存会被清空。

MySQL 8.0及之后版本已经删除了查询缓存。

对于 MySQL 8.0 之前的版本，如果想关闭查询缓存，我们可以通过将参数 query_cache_type 设置成 `DEMAND`。

查询缓存是server 层的，并不是 Innodb 存储引擎中的 buffer pool

## 解析

解析器会做如下两件事情。

**词法分析**。MySQL 会根据你输入的字符串识别出关键字出来，构建出 SQL 语法树，这样方便后面模块获取 SQL 类型、表名、字段名、 where 条件等等。

**语法分析**。根据词法分析的结果，语法解析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法。

如果我们输入的 SQL 语句语法不对，就会在解析器这个阶段报错。比如，我下面这条查询语句，把 from 写成了 form，这时 MySQL 解析器就会给报错。

表不存在或者字段不存在，并不是在解析器里做的。解析器只负责构建语法树和检查语法，但是不会去查表或者字段存不存在。

## 执行

三个阶段

- prepare 阶段，预处理阶段；
- optimize 阶段，优化阶段；
- execute 阶段，执行阶段；

###  预处理器

- 检查 SQL 查询语句中的表或者字段是否存在；
- 将 `select *` 中的 `*` 符号，扩展为表上的所有列；

###  优化器

**优化器主要负责将 SQL 查询语句的执行方案确定下来**，比如在表里面有多个索引的时候，优化器会基于查询成本的考虑，来决定选择使用哪个索引。

以在查询语句最前面加个 `explain` 命令，这样就会输出这条 SQL 语句的执行计划，然后执行计划中的 key 就表示执行过程中使用了哪个索引。

索引后面再讲

###  执行器

三种方式执行过程

**主键索引查询**

```sql
select * from product where id = 1;
```

- 执行器第一次查询，会调用 read_first_record 函数指针指向的函数，因为优化器选择的访问类型为 const，这个函数指针被指向为 InnoDB 引擎索引查询的接口，把条件 `id = 1` 交给存储引擎，**让存储引擎定位符合条件的第一条记录**。
- 存储引擎通过主键索引的 B+ 树结构定位到 id = 1的第一条记录，如果记录是不存在的，就会向执行器上报记录找不到的错误，然后查询结束。如果记录是存在的，就会将记录返回给执行器；
- 执行器从存储引擎读到记录后，接着判断记录是否符合查询条件，如果符合则发送给客户端，如果不符合则跳过该记录。
- 执行器查询的过程是一个 while 循环，所以还会再查一次，但是这次因为不是第一次查询了，所以会调用 read_record 函数指针指向的函数，因为优化器选择的访问类型为 const，这个函数指针被指向为一个永远返回 - 1 的函数，所以当调用该函数的时候，执行器就退出循环，也就是结束查询了。



**全表扫描**

```sql
select * from product where name = 'iphone';
```

- 执行器第一次查询，会调用 read_first_record 函数指针指向的函数，因为优化器选择的访问类型为 all，这个函数指针被指向为 InnoDB 引擎全扫描的接口，**让存储引擎读取表中的第一条记录**；
- 执行器会判断读到的这条记录的 name 是不是 iphone，如果不是则跳过；如果是则将记录发给客户端。Server 层每从存储引擎读到一条记录就会发送给客户端。客户端等查询语句查询完成后，才会显示出所有的记录
- 一直重复上述过程，直到存储引擎把表中的所有记录读完，然后向执行器（Server层） 返回了读取完毕的信息；
- 执行器收到存储引擎报告的查询完毕的信息，退出循环，停止查询。





**索引下推 (index condition pushdown)**

MySQL 5.6 推出的查询优化策略

```sql
# idx_age_reward
select * from t_user  where age > 20 and reward = 100000;
```

不使用索引下推执行器与存储引擎的执行流程：

- 定位到最左匹配的第一条记录， age > 20 的第一条记录。
- 获取所有满足最左匹配的数据，拿出主键，然后进行回表，再把完整的记录返回给 Server 层，Server判断reward是否满足条件，否则跳过。
- 重复操作，直到存储引擎把表中的所有符合条件的记录读完。

使用索引下推执行器与存储引擎的执行流程：

- 定位到最左匹配的第一条记录， age > 20 的第一条记录。
- 获取所有满足最左匹配的数据，判断reward是否满足条件，如果不成立则抛弃，如果成立则回表，将记录返回给 Server 层。
- 重复操作，直到存储引擎把表中的所有符合条件的记录读完。



当组合索引满足最左匹配，但是遇到非等值判断时匹配停止。进行索引下推，由存储引擎过滤剩下的组合索引条件，减少回表数据。







