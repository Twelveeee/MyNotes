# 线性表

## 顺序表

### 1.概念

定义：具有相同数据类型的n(n≥0)个数据元素组成的有限
序列。是最简单、最常用的数据结构。

• 线性表的顺序表示就是用一组地址连续的存储单
元依次存储线性表的数据元素。
• 线性表的这种机内表示称做线性表的顺序存储结
构或顺序映像。
• 通常，称这种存储结构的线性表为顺序表。

### 2.定义

```c
//静态描述
typedef struct node
{
	DataType data[maxsize];
	int length;
}sqlist;
sqlist L;

//动态描述
typedef struct node
{
	DataType *elem;
	int length;
}sqlist;
sqlist L;
L.elem=(DataType*)malloc(maxsize*sizeof(DataType))
    
```

### 3.操作

#### 1）初始化

```c
void Init_SqList（SqList *L）
{
	L->data=（DataType *)malloc(MAXSIZE*sizeof(DataType)));
	//注动态初始化才需要上一步
	L-＞length=0；
}
```

#### 2）插入

在线性表的第i-1个元素和第i个元素之前插入一个新的元素，先移动，后插入。

步骤：
(1)将ai ~ an顺序向后移动,为新元素让出位置
(2)将x置入空出的第i个位置

```c
void InsertList(SeqList *L,DataType x,int i)
{
	//在顺序线性表L中第i个位置插入新的元素X
	int j;
	if(i<1||i>L->length+1) //此时i为元素位置
	Error("position error");　　//非法位置，退出
	if(L->length>=ListSize)
	Error("overflow");　　　　//表空间溢出
	for(j=L->length-1;j>=i;j--)
	L->data[j+1]=L->data[j]; //从最后一个结点开始往后移
	L->data[i-1]=x;　　　　　 //插入x，此时i为下标
	L->length++; //表长加１
}
```



#### 3）删除

步骤： 

(1)删除ai
(2)将ai+1 ~ an， 顺序向前移动

```c
void DeleteList(Seqlist *L,int i)
{
	int j;
	if(i<1||i>L->length)
	Error("position error");
	for(j=i;j<=L->length-1;j++)
	L->data[j-1]=L->data[j]; //注意区分此时i是作为下标
	L->length--;
}
```



#### 4）查找

```c
//按值查找
int location_sqlist(sqlist *L,datatype x)
{
	//在顺序线性表L中查找值与x相等的元素
	//若找到，则返回其在L中的位序,否则返回-1
	int i;
	i=0; // i是下标
	while(i<=L->length&&L->data[i]!=x)
	i++;
	if(i<=L->length) return(i+1) ;
	else return –1;
}
//时间复杂度为：T(n)=O(n)
```



#### 5）顺序表的合并

```c
Void merge(sqlist A,sqlist B,sqlist *c)
{
	int i,j,k;//分别表示A,B,C的下标
	int i=0;j=0;k=0;
	while (i<=A.length-1 && j<=B.length-1)
	//将A与B当前小的放到C中
	if(A.data[i]<B.data[j])
	C->data[k++]=A.data[i++];
	else
	C->data[k++]=B.data[j++];
	while(i<=A.length-1)
	C->data[k++]=A.data[i++];
	while(j<=B.length-1)
	C->data[k++]=B.data[j++];
}
```



### 



## 单链表

### 1.概念

结点:数据元素及直接后继的存储位置组成一个数据元素的存储结构称为一个结点。
结点包括两个域：
数据域：存储元素本身的信息
指针域：存储直接后继的位置，指针域中存储的信息称作指针或链

单链表：由于链表的每个结点中只包含一个指针域，故又称线性链表或单链表
头指针：头指针指示链表中第一个结点的存储位置。

由于最后一个数据元素没有直接后继，则线性链表中最后一个结点的指针为“空”（NULL）

链式存储结构特点:	存储空间可以不连续。不要求逻辑上相邻的元素在物理位置上也相邻。数据元素间逻辑关系由指针域确定。

头指针（Head pointer）：头指针指示链表中第一个结点的存储位置
头结点：为了操作方便，在第一个结点之前附设的一个结点
首元结点：链表中存储信息的第一个结点

### 2.定义

```c
typedef struct node{
	DataType data;
	struct node *next;
}listnode,*LinkList;

LinkList H; //定义头指针为H，表示整个链表
listnode *p; // p为指向结点的指针变量，工作指针
```



### 3.操作

#### 1）求单链表长度

```c
int Length_LinkList(LinkList L)
{
	listnode *p;
	p=L->next;
	int j=0; //计数器
	while(p) //p!=NULL
	{
		p=p->next;
		j++;
	}
	return j;
}
```



#### 2）单链表查找

```c
//按序号查找(查找第i个元素）
Listnode * GetP (LinkList L, int i)
{ 	int j; //计数器
	Listnode *p=L ;
	j=0;
	while (p!=NULL && j<i){ 
        p=p->next;
		j++;
	}
	if (i==j) return p;
	else return NULL;
}

//按值查找
listnode * Locate_LinkList(LinkList L,DataType e)
{
	listnode *p=L->next;
	while(p !=NULL && p->data!=e)
		p=p->next;
	return p;
}
//按值查找操作的时间复杂度为O(n)。

```



#### 3）单链表插入

假设s为指向结点x的指针，则插入步骤为：
修改s指针域,使其指向p结点的后继结点:s->next=p->next
修改p指针域, 使其指向新结点s: p->next＝s

```c
void ListInsert_L(LinkList &L, DataType x，int i)
{ //在带头结点的单链线性表L中第i个位置之前插入元素x
	ListNode *p; p=L; int j=0;
	while(p!=NULL && j<i-1) //寻找第i-1 个结点
	{ 
        p= p->next; j=j+1;}
		if (j==i-1){ //若存在
			s=(linklist *) malloc (sizeof (struct node ));
			s->data=x; //③
			s->next=p->next; //④
			p->next=s; //⑤
		}
		else error (“不存在第i-1个位置”);
}
```



#### 4）单链表删除

先找到p的前驱结点q
删除p结点，修改q结点指针域 q->next＝p->next



```c
//删除第i个结点
void DeleteList(LinkList L, int i)
{
    ListNode *p，*q;
    while(p->next!=NULL&&j<i-1){ //查找i-1的结点
    	p=p->next;j++;
    }
    if (p->next==NULL || j>i-1) return error;//位置不合理
    q=p->next; //②
    p->next=q->next; //③将ai从链上摘下
    free(q); //④ 释放结点ai
}
```



#### 5）建立单链表

头插法建立单链表的算法虽然简单，但生成的链表中结点的次序和
输入数据的顺序不一致。若希望两者次序致，可采用尾插法。该方法
是将新结点插入到当前链表的表尾上，为此必须增加一个尾指针r,使其
始终指向当前链表的尾结点。如下图所示：

```c
//(头插法建立单链表）
LinkList CreatListF(LinkList &L){
    //从表尾到表头逆向建立单链表L,每次均在头结点之后插入元素
    ListNode *s;int x;
    L=(LinkList)malloc(sizeof(ListNode )); //创建头结点
    L->next=NULL; //初始为空链表
    scanf("%d", &x); //输入结点的值
    while(x!= 9999){ //输入 9999表示结束
        s=(ListNode *) malloc(sizeof(ListNode )); //创建新结点
        s->data=x;
        s->next=L->next;
        L->next=s; //将新结点插入表中，L为头指针
        scanf("%d", &x);
	} //while 结束
	return L;
}


//（尾插法建立单链表）
LinkList CreatListR(LinkList &L){
    // 从表头到表尾正向建立单链表L,每次均在表尾插入元素
    int x; // 设元素类型为整型
    L=(LinkList)malloc(sizeof(ListNode));
    ListNode *s, *r = L; // r为表尾指针
    scanf ("%d"，&x); //输入结点的值
    while(x!=9999){ //输入 9999表示结束
        s=(ListNode *)malloc(sizeof(ListNode );
        s->data=x; r->next=s;
        r=s; //r指向新的表尾结点
        scanf("%d", &x);
    }
    r->next = NULL; //尾结点指针置空
    return L;
}
```



#### 6）单链表逆置

```c
Void nizhi(Linklist &L)
{
    ListNode *p, *s;
    P=L->next; L->next=NULL; //变成两个链表
    While(p!=NILL){
        s=p;
        p=p->next;
        s->next=L->next; //头插法
        L->next = s; //头插法
    }
}
```



#### 7）单链表合并

```c
//将两个有序链表并为一个有序链表
void Linklist_Merge(LinkList &La, LinkList &Lb, LinkList &Lc) {
//已知单链线性表La和Lb的元素按值非递减排列。
//归并La和Lb得到新的单链线性表Lc,Lc的元素也按值非递减排列。
    ListNode *pa, *pb, *crear,*s;
    // crear指向LC的尾巴
    pa = La->next; pb = Lb-> next; crear = Lc; 
    while (pa!=NULL && pb!=NULL) {
    	if (pa->data <= pb->data) {
       		s=pa; pa=pa->next;
        	s->next = crear->next; crear->next = s;
            crear = crear->next; 
        }else{
            s=pb; pb=pb->next;
    		s->next = crear->next;
            crear->next = s;
            crear = crear->next;
        }
    }
    if(pa!=NULL)crear->next = pa;
    else crear->next = pb;
} // MergeList_L
```

## 循环链表

### 1.概念

循环链表是线性表的另一种链式存储结构,它的特点是将线性链表的最后一个结点指针指向链表的第一个结点。

优点:从任意位置开始可以访问链中任意结点。

判空：L->next==L

判空：L->next==L

判尾：P->next==L; P==L ;

2.定义

3.操作

## 双向链表

### 1.概念

在双向链表中,每个结点有两个指针域，一个指向后继
结点，另一个指向直接前驱结点。

判空：

```c
L->next==Null  &&  L->prior==Null
```



### 2.定义

```c
typedef struct DuLNode {
    DataType data;
    struct DuLNode *prior;
    struct DuLNode *next;
}DuLNode, *DuLinkList;

//定义头指针： DuLinkList L;
//定义工作指针： DuLNode *p;
```

双向链表具有对称性：
p->prior->next=p=p->next->prior

### 3.操作

#### 1)插入

```C
//在P后面插入：
s->next = p->next;
s->prior = p;
p->next->prior = s;
p->next = s;

//在P前面插入：
s->next = p;
s->prior = p->prior;
p->prior->next = s;
p->prior = s;

//插入P：
p->next = q->next;
p->prior = q;
q->next->prior = p;
q->next = p;
```

#### 2）删除

```c
//删除P后边的结点
q = p->next;
q->next->prior = p;
p->next = q->next;
free(q);

//删除P前边的结点
q = p->prior;
q->prior->next = p;
p->prior = q->prior;
free(q);

//删除P
p->prior->next = p->next;
p->next->prior = p->prior;
free(p);
```



## 链表与顺序表的比较

顺序表:
• 需要预分配一定长度的存储空间。太大易造成存储空间的浪费，太小又将造成频繁地进行存储空间的再分配。
• 顺序表是一种随机存取的结构，对顺序表中任一元素进行存取的时间相同。
• 顺序表对插入、删除操作需要移动近一半的数据元素。

链表:
• 存储分配灵活，链表中的结点可在程序执行过程中动态生成。
• 链表是一种顺序存取的结构，对链表中的每个结点都必须从头指针所指结点起顺链扫描。
• 链表对插入、删除操作不需要移动数据元素。