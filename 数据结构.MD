# 线性表

## 顺序表

### 1.概念

定义：具有相同数据类型的n(n≥0)个数据元素组成的有限
序列。是最简单、最常用的数据结构。

• 线性表的顺序表示就是用一组地址连续的存储单
元依次存储线性表的数据元素。
• 线性表的这种机内表示称做线性表的顺序存储结
构或顺序映像。
• 通常，称这种存储结构的线性表为顺序表。

### 2.定义

```c
//静态描述
typedef struct node
{
	DataType data[maxsize];
	int length;
}sqlist;
sqlist L;

//动态描述
typedef struct node
{
	DataType *elem;
	int length;
}sqlist;
sqlist L;
L.elem=(DataType*)malloc(maxsize*sizeof(DataType))
    
```

### 3.操作

1）初始化

```c
void Init_SqList（SqList *L）
{
	L->data=（DataType *)malloc(MAXSIZE*sizeof(DataType)));
	//注动态初始化才需要上一步
	L-＞length=0；
}
```

2）插入

在线性表的第i-1个元素和第i个元素之前插入一个新的元素，先移动，后插入。

步骤：
(1)将ai ~ an顺序向后移动,为新元素让出位置
(2)将x置入空出的第i个位置

```c
void InsertList(SeqList *L,DataType x,int i)
{
	//在顺序线性表L中第i个位置插入新的元素X
	int j;
	if(i<1||i>L->length+1) //此时i为元素位置
	Error("position error");　　//非法位置，退出
	if(L->length>=ListSize)
	Error("overflow");　　　　//表空间溢出
	for(j=L->length-1;j>=i;j--)
	L->data[j+1]=L->data[j]; //从最后一个结点开始往后移
	L->data[i-1]=x;　　　　　 //插入x，此时i为下标
	L->length++; //表长加１
}
```



3）删除

步骤： 

(1)删除ai
(2)将ai+1 ~ an， 顺序向前移动

```c
void DeleteList(Seqlist *L,int i)
{
	int j;
	if(i<1||i>L->length)
	Error("position error");
	for(j=i;j<=L->length-1;j++)
	L->data[j-1]=L->data[j]; //注意区分此时i是作为下标
	L->length--;
}
```



4）查找

```c
//按值查找
int location_sqlist(sqlist *L,datatype x)
{
	//在顺序线性表L中查找值与x相等的元素
	//若找到，则返回其在L中的位序,否则返回-1
	int i;
	i=0; // i是下标
	while(i<=L->length&&L->data[i]!=x)
	i++;
	if(i<=L->length) return(i+1) ;
	else return –1;
}
//时间复杂度为：T(n)=O(n)
```



5）顺序表的合并

```c
Void merge(sqlist A,sqlist B,sqlist *c)
{
	int i,j,k;//分别表示A,B,C的下标
	int i=0;j=0;k=0;
	while (i<=A.length-1 && j<=B.length-1)
	//将A与B当前小的放到C中
	if(A.data[i]<B.data[j])
	C->data[k++]=A.data[i++];
	else
	C->data[k++]=B.data[j++];
	while(i<=A.length-1)
	C->data[k++]=A.data[i++];
	while(j<=B.length-1)
	C->data[k++]=B.data[j++];
}
```



### 



## 链表

### 单链表

#### 1.概念

结点:数据元素及直接后继的存储位置组成一个数据元素的存储结构称为一个结点。
结点包括两个域：
数据域：存储元素本身的信息
指针域：存储直接后继的位置，指针域中存储的信息称作指针或链

单链表：由于链表的每个结点中只包含一个指针域，故又称线性链表或单链表
头指针：头指针指示链表中第一个结点的存储位置。

由于最后一个数据元素没有直接后继，则线性链表中最后一个结点的指针为“空”（NULL）

链式存储结构特点:	存储空间可以不连续。不要求逻辑上相邻的元素在物理位置上也相邻。数据元素间逻辑关系由指针域确定。

头指针（Head pointer）：头指针指示链表中第一个结点的存储位置
头结点：为了操作方便，在第一个结点之前附设的一个结点
首元结点：链表中存储信息的第一个结点

#### 2.定义

```c
typedef struct node{
	DataType data;
	struct node *next;
}listnode,*LinkList;

LinkList H; //定义头指针为H，表示整个链表
listnode *p; // p为指向结点的指针变量，工作指针
```



#### 3.操作

1）求单链表长度

```c
int Length_LinkList(LinkList L)
{
	listnode *p;
	p=L->next;
	int j=0; //计数器
	while(p) //p!=NULL
	{
		p=p->next;
		j++;
	}
	return j;
}
```



2）单链表查找

```c
//按序号查找(查找第i个元素）
Listnode * GetP (LinkList L, int i)
{ 	int j; //计数器
	Listnode *p=L ;
	j=0;
	while (p!=NULL && j<i){ 
        p=p->next;
		j++;
	}
	if (i==j) return p;
	else return NULL;
}

//按值查找
listnode * Locate_LinkList(LinkList L,DataType e)
{
	listnode *p=L->next;
	while(p !=NULL && p->data!=e)
		p=p->next;
	return p;
}
//按值查找操作的时间复杂度为O(n)。

```



3）单链表插入

假设s为指向结点x的指针，则插入步骤为：
修改s指针域,使其指向p结点的后继结点:s->next=p->next
修改p指针域, 使其指向新结点s: p->next＝s

```c
void ListInsert_L(LinkList &L, DataType x，int i)
{ //在带头结点的单链线性表L中第i个位置之前插入元素x
	ListNode *p; p=L; int j=0;
	while(p!=NULL && j<i-1) //寻找第i-1 个结点
	{ 
        p= p->next; j=j+1;}
		if (j==i-1){ //若存在
			s=(linklist *) malloc (sizeof (struct node ));
			s->data=x; //③
			s->next=p->next; //④
			p->next=s; //⑤
		}
		else error (“不存在第i-1个位置”);
}
```



4）单链表删除

先找到p的前驱结点q
删除p结点，修改q结点指针域 q->next＝p->next



```c
//删除第i个结点
void DeleteList(LinkList L, int i)
{
    ListNode *p，*q;
    while(p->next!=NULL&&j<i-1){ //查找i-1的结点
    	p=p->next;j++;
    }
    if (p->next==NULL || j>i-1) return error;//位置不合理
    q=p->next; //②
    p->next=q->next; //③将ai从链上摘下
    free(q); //④ 释放结点ai
}
```



5）建立单链表

头插法建立单链表的算法虽然简单，但生成的链表中结点的次序和
输入数据的顺序不一致。若希望两者次序致，可采用尾插法。该方法
是将新结点插入到当前链表的表尾上，为此必须增加一个尾指针r,使其
始终指向当前链表的尾结点。如下图所示：

```c
//(头插法建立单链表）
LinkList CreatListF(LinkList &L){
    //从表尾到表头逆向建立单链表L,每次均在头结点之后插入元素
    ListNode *s;int x;
    L=(LinkList)malloc(sizeof(ListNode )); //创建头结点
    L->next=NULL; //初始为空链表
    scanf("%d", &x); //输入结点的值
    while(x!= 9999){ //输入 9999表示结束
        s=(ListNode *) malloc(sizeof(ListNode )); //创建新结点
        s->data=x;
        s->next=L->next;
        L->next=s; //将新结点插入表中，L为头指针
        scanf("%d", &x);
	} //while 结束
	return L;
}


//（尾插法建立单链表）
LinkList CreatListR(LinkList &L){
    // 从表头到表尾正向建立单链表L,每次均在表尾插入元素
    int x; // 设元素类型为整型
    L=(LinkList)malloc(sizeof(ListNode));
    ListNode *s, *r = L; // r为表尾指针
    scanf ("%d"，&x); //输入结点的值
    while(x!=9999){ //输入 9999表示结束
        s=(ListNode *)malloc(sizeof(ListNode );
        s->data=x; r->next=s;
        r=s; //r指向新的表尾结点
        scanf("%d", &x);
    }
    r->next = NULL; //尾结点指针置空
    return L;
}
```



6）单链表逆置

```c
Void nizhi(Linklist &L)
{
    ListNode *p, *s;
    P=L->next; L->next=NULL; //变成两个链表
    While(p!=NILL){
        s=p;
        p=p->next;
        s->next=L->next; //头插法
        L->next = s; //头插法
    }
}
```



7）单链表合并

```c
//将两个有序链表并为一个有序链表
void Linklist_Merge(LinkList &La, LinkList &Lb, LinkList &Lc) {
//已知单链线性表La和Lb的元素按值非递减排列。
//归并La和Lb得到新的单链线性表Lc,Lc的元素也按值非递减排列。
    ListNode *pa, *pb, *crear,*s;
    // crear指向LC的尾巴
    pa = La->next; pb = Lb-> next; crear = Lc; 
    while (pa!=NULL && pb!=NULL) {
    	if (pa->data <= pb->data) {
       		s=pa; pa=pa->next;
        	s->next = crear->next; crear->next = s;
            crear = crear->next; 
        }else{
            s=pb; pb=pb->next;
    		s->next = crear->next;
            crear->next = s;
            crear = crear->next;
        }
    }
    if(pa!=NULL)crear->next = pa;
    else crear->next = pb;
} // MergeList_L
```

### 循环链表

#### 1.概念

循环链表是线性表的另一种链式存储结构,它的特点是将线性链表的最后一个结点指针指向链表的第一个结点。

优点:从任意位置开始可以访问链中任意结点。

判空：L->next==L

判空：L->next==L

判尾：P->next==L; P==L ;

2.定义

3.操作

### 双向链表

#### 1.概念

在双向链表中,每个结点有两个指针域，一个指向后继
结点，另一个指向直接前驱结点。

判空：

```c
L->next==Null  &&  L->prior==Null
```



#### 2.定义

```c
typedef struct DuLNode {
    DataType data;
    struct DuLNode *prior;
    struct DuLNode *next;
}DuLNode, *DuLinkList;

//定义头指针： DuLinkList L;
//定义工作指针： DuLNode *p;
```

双向链表具有对称性：
p->prior->next=p=p->next->prior

#### 3.操作

1)插入

```C
//在P后面插入：
s->next = p->next;
s->prior = p;
p->next->prior = s;
p->next = s;

//在P前面插入：
s->next = p;
s->prior = p->prior;
p->prior->next = s;
p->prior = s;

//插入P：
p->next = q->next;
p->prior = q;
q->next->prior = p;
q->next = p;
```

2）删除

```c
//删除P后边的结点
q = p->next;
q->next->prior = p;
p->next = q->next;
free(q);

//删除P前边的结点
q = p->prior;
q->prior->next = p;
p->prior = q->prior;
free(q);

//删除P
p->prior->next = p->next;
p->next->prior = p->prior;
free(p);
```



### 链表与顺序表的比较

顺序表:
• 需要预分配一定长度的存储空间。太大易造成存储空间的浪费，太小又将造成频繁地进行存储空间的再分配。
• 顺序表是一种随机存取的结构，对顺序表中任一元素进行存取的时间相同。
• 顺序表对插入、删除操作需要移动近一半的数据元素。

链表:
• 存储分配灵活，链表中的结点可在程序执行过程中动态生成。
• 链表是一种顺序存取的结构，对链表中的每个结点都必须从头指针所指结点起顺链扫描。
• 链表对插入、删除操作不需要移动数据元素。

## 栈

栈是限定仅在表尾进行插入和删除操作的线性表。

修改栈的原则：先进后出(FILO, First In Last Out)或后进先出(LIFO)

### 顺序栈

#### 1.概念



顺序存储结构：利用一组地址连续的存储单元依次存放自栈底到栈顶的数据元素。

顺序栈：顺序存储结构的栈称为顺序栈。



#### 2.定义



```c
//1.顺序栈的静态定义
#define MAXSIZE 1024
typedef struct
{
	ElemType data[MAXSIZE];
	int top;
}SqStack;
```



```C
//2.顺序栈的动态定义
typedef struct{
	SElemType *base;
	SElemType *top;
	int stacksize;
}SqStack;
```





#### 3.静态栈的基本操作

```c
当栈空：sq.top==0
入栈：sq.data[sq.top]=x; sq.top++;
出栈：sq.top--; x=sq.data[sq.top];
栈满：sq.top==Maxsize
上溢：当栈满时再做进栈运算时产生空间溢出称为上溢。出
错状态应当避免
下溢：当栈空时再做退栈运算也将产生溢出称为下溢。是正
常现象，可用作程序控制转移件
```



```c
当栈空：sq.top==-1
入栈：sq.top++;sq.data[sq.top]=x;
出栈：x=sq.data[sq.top];sq.top--;
栈满：sq.top==Maxsize-1
上溢：当栈满时再做进栈运算时产生空间溢出称为上溢。出
错状态应当避免。
下溢：当栈空时再做退栈运算也将产生溢出称为下溢。是正
常现象，可用作程序控制转移件。
```

#### 4.动态栈的基本操作

```c
栈空： sq.top == sq.base
栈满： sq.top-sq.base>=sq.stacksize
读栈顶元素： e = *(sq.top- 1)
入栈：*sq.top++ = e;
出栈: e = *--sq.top;
```

1)初始化

```c
Status InitStack (SqStack &S) {
	//构造一个空栈S
	S.base = (SElemType) *malloc(STACK_INIT_SIZE*sizeof(SElemType));
	if (!S.base) exit (OVERFLOW); // 存储分配失败
	S.top = S.base;
	S.stacksize = STACK_INIT_SIZE;
	return OK;
}// InitStack
```

2)读栈顶元素

```c
Status GetTop(SqStack S, SELemType &e) {
	// 若栈不空，则用e返回S的栈顶元素并返回0K;否则返回ERROR
	if(S.top == s.base) return ERROR;
	e = *(S.top- 1);
	return OK;
}// GetTop
```



3)进栈

```c
Status Push (SqStack &S, SElemType e){
	//插入元素e为新的栈顶元素
	if(S.top - S.base >= S.stacksize) {//栈满,追加存储空间
		S.base = (SElemType *) realloc (S.base,
		(S.stacksize + STACKINCREMENT)*sizeof(SElemType));
		if (!S.base) exit (OVERFLOW); //存储分配失败
		S.top = S.base + S.stacksize;
		S.stacksize += STACKINCREMENT;
	}
	*s.top++ =e;
	return 0K;
}// Push
```



4)退栈

```c
Status Pop (SqStack &S, SElenmType &e) {
	//若栈不空,则删除S的栈顶元素,用e返回其值，并返回
	//0K;否则返回ERROR
	if(S.top == S.base) return EROR;
	e = * --S.top;
	return 0K;
}// Pop
```





### 链栈

#### 1.概念

链式存储结构：用于收集计算机存储器中所有空闲存储空间,来保存自栈底到栈顶的数据元素。

链栈：链式存储结构栈称为链栈。

#### 2.定义

```c
typedef struct node
{
	StackElementType data;
	struct node *next;
}LinkStackNode;
typedef LinkStackNode *LinkStack;
```

#### 3.操作

1)进栈

```c
int Push(LinkStack top, StackElementType x)
/* 将数据元素 x 压入栈 top 中 */
{
	LinkStackNode * temp;
	temp=(LinkStackNode * )malloc(sizeof(LinkStackNode));
	if(temp==NULL) return(FALSE); /* 申请空间失败 */
	temp->data=x;
	temp->next=top->next;
	top->next=temp; /* 修改当前栈顶指针 */
	return(TRUE);
}

```

2)出栈

```c
int Pop(LinkStack top, StackElementType *x)
/* 将栈 top 的栈顶元素弹出，放到 x 所指的存储空间中 */
{ 
	LinkStackNode * temp;
	temp=top->next;
	if(temp==NULL)return(FALSE); /*栈为空*/
	top->next=temp->next;
	*x=temp->data;
	free(temp); /* 释放存储空间 */
	return(TRUE);
}

```

### 栈的应用

#### 1.括号匹配的检验

```c
int pipei()
{ 
    sqstack s; char c; s.top=0; scanf(“%c”,&c);
	while(c!=’#’){
        switch(c){
            case ‘(‘ : push(s,c); scanf(“%c”,&c)；break;
			case ‘{‘ : push(s,c); scanf(“%c”,&c)；break;
			case ‘<‘ : push(s,c); scanf(“%c”,&c)；break;
			case ‘)‘ : if(s.top==0) return -1; else if(*(s.top-1)==”(”) pop(s);
			scanf(“%c”,&c);break; else return -1;
			case ‘}‘ : if(s.top==0) return -1; else if(*(s.top-1)==”{”) pop(s);
			scanf(“%c”,&c);break; else return -1;
			case ‘>‘ : if(s.top==0) return -1; else if(*(s.top-1)==”<”) pop(s);
			scanf(“%c”,&c);break; else return -1;
           	}
    }
	if(s.top!=0) return -1;
	else return 0;
}
```

#### 2.表达式求值

为实现算法，使用两个工作栈。一个称做OPTR,用以寄存运算符；另一个称做OPND,用以寄存操作数或运算结果。算法的基本思想是:
(1) 首先置操作数栈为空栈，表达式起始符“#”为运算符栈的栈底元素；
(2) 依次读入表达式中每个字符，若是操作数则进OPND栈，若是运算符则和OPTR栈的栈顶运算符比较优先权，然后作相应操作,直至整个表达式求值完毕(即OPTR栈的栈顶元素和当前读入的字符均为“#”)。



```c
OperandType EvaluateExpression(){
	//算术表达式求值的算符优先算法。设OPTR和OPND分别为运算符栈和运算数栈
	//OP为运算符集合OPS 为运算符集合
	InitStack (OPTR);
    Push (OPTR,'#' );
	InitStack (OPND) ;
    C= getchar();
	while (c!='#' II GetTop(OPTR)!='#') {
		if (! In(C, 0P)) {
            Push((OPND, C); C = getchar(); 
        }else{//不是运算符则进栈
			switch (Precede( GetTop(0PTR)，c)) {
				case '<': //栈顶元素优先权低
					Push(OPTR, c); c = getchar(); break;
				case '=': // 脱括号并接收下一字符
					Pop(OPTR, x); c = getchar();break;
				case'>' : //退栈并将运算结果入栈
					Pop(OPTR, theta);
					Pop(OPND, b); Pop(OPND, a);
					Push(OPND, Operate(a, theta, b)) ;break;
				}
            }
	}
	return GetTop( OPND) ;
} // EvaluateExpression
```

## 队列

### 1.概念

队列是只允许在一端删除，另一端插入的线性表，允许删除的一端叫队头（front),

允许插入的一端叫队尾（rear）。

特点：先进先出(FIFO)

### 2.顺序队列

1.语言描述

```c
#define MAXSIZE 1024 //最大队列长度
typedef struct
{
datatype data[MAXSIZE]; /*队员的存储空间*/
int rear,front; /*队头队尾指针*/
}SqQueue;
```

2.具体操作

```c
置空队: sq.front= sq.rear=0
入队: sq.data[sq.rear]=x; sq.rear++;
出队: x=sq.data[sq.front] sq.front++;
读队头、队尾: sq.data[sq.front] sq.data[sq.rear-1]
队中元素个数:m=sq.rear-sq.front
队满:m==MAXSIZE
队空:m==0
```

3.顺序队列的假溢出

如图（无图）所示的状态，不能再继续插入新的队尾元素，否则会因为数组越界导致程序代码被破坏。而此时又不宜如顺序栈那样，进行存储空间再分配来扩大数组的空间，因为队列的实际可用空间并未占满，这种情况叫做顺序队列的假溢出。

解决方案：

​	① 队首固定，每次出队剩余元素向下移动——浪费时间。
​	② 循环队列。

### 3.循环队列

1)定义

```c
队空 sq.front==sq.rear
队满 sq.front==sq.rear
或者:
	另外设一个标志存储队中元素个数num==0代表队空，num==MAXSIZE代表队满
	少用一个元素空间：
	队空：front==rear
	队满：(rear+1)%M==front
```

2)基本操作

```c
typedef struct
{
	datatype data[M] ;
	int front ;
    int rear ;
	int count ; //记录队中元素个数
} cirqueue ;

```

```c
//0)初始化
	q->front=q->rear = 0;
//1）判队空
	q.count == 0;

//2) 判队满
	q.count == M;

//3) 读队头元素
datatype get_queue (cirqueue q)
{
	if(q.count == 0 ){
        printf ( “queue null “ ) ;
        exit (0) ;
    }
	return ( q.data [q.front]);
}

//4) 入队
void enqueue（cirqueue * q, datatype x ）{
    // 判队满
    if (q->count = = M) { printf(“over flow “) ; exit(0);}
    
	q->data[q->rear ] = x ;
	q->rear = (q->rear+1)% M ; //插入元素 x
	q->count ++ ; //修改表长
}

//5) 出队
datatype dequeue(cirqueue * q , datatype x ){
    //判队空
    if(q->count == 0 ) {printf (“queue null”) ; exit(0); }
    
	x=q->data[q ->font];
	q->front = (q->front + 1)%M ; //删除队头元素
	q->count-- ; //修改表长
	return (x) ;
}
```



### 4.链队列

1)定义

```c
typedef struct Node
{
     QueueElementType data; /*数据域*/
     struct Node *next; /*指针域*/
}LinkQueueNode;

typedef struct
{
	 LinkQueueNode * front;
	 LinkQueueNode * rear;
}LinkQueue;
```

2)初始化

```c
int InitQueue(LinkQueue * Q)
{ /* 将 Q 初始化为一个空的链队列 */
	 Q->front=(LinkQueueNode *)malloc(sizeof(LinkQueueNode));
	 if(Q->front!=NULL){
		Q->rear=Q->front;
		Q->front->next=NULL;
		return(TRUE);
	}else return(FALSE); /* 溢出！*/
}
```

3)入队

```c
链队列入队操作算法
int EnterQueue(LinkQueue *Q, QueueElementType x)
{ /* 将数据元素 x 插入到队列 Q 中 */
	LinkQueueNode * NewNode;
	NewNode=(LinkQueueNode * )malloc(sizeof(LinkQueueNode));
	if(NewNode!=NULL){
		NewNode->data=x;
		NewNode->next=NULL;
		Q->rear->next=NewNode;
		Q->rear=NewNode;
		return(TRUE);
	}else return(FALSE); /* 溢出！*/
}

```

4)出队

```c
int DeleteQueue(LinkQueue * Q, QueueElementType *x)
{ /* 将队列 Q 的队头元素出队，并存放到 x 所指的存储空间中 */
	LinkQueueNode * p;
	if(Q->front==Q->rear)return(FALSE);
	p=Q->front->next;
	Q->front->next=p->next; /* 队头元素 p 出队 */
    /* 如果队中只有一个元素 p，则 p 出队后成为空队*/
	if(Q->rear==p) Q->rear=Q->front;
	*x=p->data;
	free(p); /* 释放存储空间 */
	return(TRUE);
}
```

### 



