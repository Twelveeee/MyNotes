# 1、Linux操作系统

## 1.1 什么是操作系统

**操作系统**英文原称Operating System(简称**OS**)，主要功能是实现计算机硬件与软件的直接控制，并进行管理协调。
**服务器操作系统**一般指的是安装在大型计算机上的操作系统，比如Web服务器、应用服务器和数据库服务器等，是企业IT系统的基础架构平台，相比个人版操作系统，服务器操作系统要承担额外的管理、配置、稳定、安全等功能，处于每个网络中的心脏部位。
服务器操作系统主要分为四大流派：WINDOWS、NETWARE、UNIX、LINUX。

**Linux**操作系统是国外一些编程爱好者在Posix和Unix基础上开发出来的，支持多用户、多任务、多线程、多CPU。
Linux开放源代码政策，使得基于其平台的开发与使用无须支付任何单位和个人的版权费用，成为后来很多操作系统厂家创业的基石，同时也成为目前国内外很多保密机构服务器操作系统采购的首选。

## 1.2 Linux操作系统发展与起源

Linux最早是**Linus Torvalds**在1991年开始设计开发的。
Linus是芬兰人，赫尔辛基是芬兰的首都，当时他正是赫尔辛基大学计算机系的学生，23岁。
芬兰是北欧的一个小国，国土大部分处在北极圈内。Linux的标志是可爱的企鹅，取自芬兰的吉祥物。

## 1.3 主流Linux操作系统介绍

**CentOs**

CentOS（Community Enterprise Operating System，中文意思是：社区企业操作系统）是Linux发行版之一，它是来自于Red Hat Enterprise Linux依照开放源代码规定释出的源代码所编译而成。
由于出自同样的源代码，因此有些要求高度稳定性的服务器以CentOS替代商业版的Red Hat Enterprise Linux使用。两者的不同，在于CentOS并不包含封闭源代码软件。



**Ubuntu**

Ubuntu（乌班图）是一个以桌面应用为主的Linux操作系统，其名称来自非洲南部祖鲁语或豪萨语的“ubuntu”一词，意思是“人性”、“我的存在是因为大家的存在”。
Ubuntu基于Debian发行版和GNOME桌面环境，Ubuntu的目标在于为一般用户提供一个最新的、同时又相当稳定的主要由自由软件构建而成的操作系统。Ubuntu具有庞大的社区力量，用户可以方便地从社区获得帮助。2013年1月3日，Ubuntu正式发布面向智能手机的移动操作系统。



**自由的Debian**

初始版本：1993年8月16日
DebianGNU/Linux是由一个叫做伊恩·默多克（IanMurdock）的牛人在1993年发起的，他的名字以Ian开头，他太太的名字Debra开头三个字母是Deb，于是在爱情的力量下，他发起了DebianGNU/Linux组织。

# 2、新手必须掌握的Linux命令

## 1、强大好用的shell

### 1.1 什么是shell

- 计算机硬件是由运算器、控制器、存储器、输入/输出设备等共同组成的，而让各种硬件设备各司其职且又能协同运行的东西就是系统内核。

- Linux系统的内核负责完成对硬件资源的分配、调度等管理任务。由此可见，系统内核对计算机的正常运行来讲是太重要了，因此一般不建议直接去编辑内核中的参数，而是让用户通过基于系统调用接口开发出的程序或服务来管理计算机，以满足日常工作的需要
- Shell就是这样的一个命令行工具。
- Shell（也称为终端或壳）充当的是人与内核（硬件）之间的翻译官，用户把一些命令“告诉”终端，它就会调用相应的程序服务去完成某些工作。
- 现在包括红帽系统在内的许多主流Linux系统默认使用的终端是Bash（Bourne-Again SHell）解释器。

### 1.2 bash介绍

- bash是一个为GNU计划编写的Unix shell。它的名字是一系列缩写：Bourne-Again Shell。
- Bourne shell是一个早期的重要shell，由史蒂夫·伯恩在1978年前后编写，并同Version 7 Unix一起发布。bash则在1987年由布莱恩·福克斯创造。

### 1.3 bash主要功能

命令行编辑功能
命令和文件名补全功能
命令历史功能
命令别名功能
提供作业控制功能
具有将命令序列定义为功能键的功能
灵活的Shell脚本编程

## 2、执行查看帮助命令

### 2.1 Linux命令格式

Linux系统中已经有了Bash这么好用的“翻译官”，那么接下来就有必要好好学习下怎么跟
它沟通了。要想准确、高效地完成各种任务，仅依赖于命令本身是不够的，还应该根据实际
情况来灵活调整各种命令的参数。
Linux命令格式由三部分组成：**命令名称，命令选项，命令参数。**

**语法格式**：命令名称 [命令选项] [命令参数]



**命令参数**一般是指要处理的文件、目录、用户等资源。
**命令选项**可以用长格式（完整的选项名称），也可以用短格式（单个字母的缩写），两者分
别用--与-作为前缀。
Linux新手不会执行命令大多是因为参数比较复杂，参数值需要随不同的命令和需求情况而
发生改变。

### 2.2 Linux命令中的其他组成

命令提示符是在操作系统中，提示进行命令输入的一种工作提示符。在不同的操作系统
环境下，命令提示符各不相同。
在Linux环境中，输入界面中的如下所示是命令提示符，表示命令输入的状态。

[当前用户账号@当前主机名 路径最后一个目录 ]#或者$
管理员root用户的提示符“#”
```[root@localhost ~]#```
普通用户提示符“$”
```[teacher@localhost ~]$```

命令的各组成部分之间用空格分隔
命令的输入以**回车键**结束
一般一行输入一条命令
命令区分大小写
如果命令过长，可以输入“\”符号进行换行继续输入

### 2.3 Linux帮助命令

help命令
用于显示shell内部命令的帮助信息
$ help pwd
“--help”命令选项
$ touch --help



使用man命令阅读手册页
man指令可以查看Linux中的指令帮助、配置文件帮助和编程帮助等信息
$ man ls

## 3、常用系统工作命令

**1．echo命令**

echo命令用于在终端输出字符串或变量提取后的值，格式为“echo [字符串 | $变量]”。
例如，把指定字符串“Linux”输出到终端屏幕的命令为：
```	[root@linux ~]# echo Linux```
该命令会在终端屏幕上显示如下信息：
```	Linux```

**2．date命令**

date命令用于显示及设置系统的时间或日期，格式为“date [选项] [+指定的格式]”。
只需在强大的date命令中输入以“+”号开头的参数，即可按照指定格式来输出系统的时间或日期，这样在日常工作时便可以把备份数据的命令与指定格式输出的时间信息结合到一起。

| 参数 |       作用       |
| :--: | :--------------: |
|  %t  |     [tab键]      |
|  %H  | 小时（24小时制） |
|  %I  | 小时（12小时制） |
|  %M  |       分钟       |
|  %S  |        秒        |
|  %j  |  今年中的第几天  |

**3．reboot命令**

reboot命令用于重启系统，其格式为reboot。
由于重启计算机这种操作会涉及硬件资源的管理权限，因此默认只能使用root管理员来重启，其命令如下：
```root@linux ~]# reboot```

**4．poweroff命令**

poweroff命令用于关闭系统，其格式为poweroff。
该命令与reboot命令相同，都会涉及硬件资源的管理权限，因此默认只有root管理员才可以关闭电脑，其命令如下：
```[root@linux ~]# poweroff```

**5．ps命令**

ps命令用于查看系统中的进程状态，格式为“ps [选项]”。
**常用选项：**
-a显示所有进程（包括其他用户的进程）
-u用户以及其他详细信息
-x显示没有控制终端的进程

**6．top命令**

top命令用于动态地监视进程活动与系统负载等信息，其格式为top。
top命令相当强大，能够动态地查看系统运维状态，完全将它看作Linux中的“强化版的Windows任务管理器”。

## 4、系统状态检测命令

**1．ip addr命令**

ip addr命令用于获取网卡配置与网络状态等信息。
使用Ip addr命令来查看本机当前的网卡配置与网络状态等信息时，其实主要查看的就是网卡名称、inet参数后面的IP地址、ether参数后面的网卡物理地址（又称为MAC地址)：

**2．uname命令**

uname命令用于查看系统内核与系统版本等信息，格式为“uname [-a]”。
在使用uname命令时，一般会固定搭配上-a参数来完整地查看当前系统的内核名称、主机名、内核发行版本、节点名、系统时间、硬件名称、硬件平台、处理器类型以及操作系统名称等信息。

**3．uptime命令**

uptime用于查看系统的负载信息，格式为uptime。
uptime命令可以显示当前系统时间、系统已运行时间、启用终端数量以及平均负载值等信息。平均负载值指的是系统在最近1分钟、5分钟、15分钟内的压力情况；负载值越低越好，尽量不要长期超过1，在生产环境中不要超过5。

**4．free命令**

free用于显示当前系统中内存的使用量信息，格式为“free [-h]”。
为了保证Linux系统不会因资源耗尽而突然宕机，运维人员需要时刻关注内存的使用量。在使用free命令时，可以结合使用-h参数以更人性化的方式输出当前内存的实时使用量信息。

**5．who命令**

who用于查看当前登入主机的用户终端信息，格式为“who [选项]”。
这三个简单的字母可以快速显示出所有正在登录本机的用户的名称以及他们正在开启的终端
信息。

**6．last命令**

last命令用于查看所有系统的登录记录，格式为“last [选项]”。
使用last命令可以查看本机的登录记录。但是，由于这些信息都是以日志文件的形式保存在
系统中，因此黑客可以很容易地对内容进行篡改。千万不要单纯以该命令的输出信息而判断
系统有无被恶意入侵

**7．history命令**

命令历史功能的使用
使用上下方向键浏览已输入命令（历史命令）
[root@localhost ~]# history [选项] [历史命令保存文件]
选项：
-c：清空历史命令
-w：把缓存中的历史命令写入历史命令保存文件~/.bash_history历史命令默认会保存1000条,可以在环境变量配置文件/etc/profile中进行修改
历史命令的调用
使用上、下箭头调用以前的历史命令
使用“!n”重复执行第n条历史命令
使用“!!”重复执行上一条命令
使用“!字串”重复执行最后一条以该字符串开头的命令

## 5、工作目录切换命令

### 5.1linux目录介绍

**树型目录结构**
Linux文件系统采用了多级目录的树型层次结构管理文件。树型结构的最上层是根目录，用／表示。在根目录之下是各层目录和文件。

**工作目录与用户主目录**
当登录Linux时，首先进入到一个特殊的目录，称为主/登录目录。可以通过～来指定(或者引用)主目录。
当前所在的目录称为当前工作目录(又称当前目录)，当前目录可以用“.”表示，当前工作目录的父目录可用“..”表示。

| 目录名     | **说明**                                                     |
| ---------- | ------------------------------------------------------------ |
| **/**      | **Linux系统根目录**                                          |
| /bin       | 存放普通用户可执行文件，系统中的任何用户都可以执行该目录中的命令 |
| /sbin      | 存放系统的管理命令，普通用户不能执行该目录中的命令           |
| **/home**  | **普通用户的主目录，每个用户在该目录下都有一个与用户名同时的目录** |
| **/etc**   | **存放系统配置和管理文件，这些文件都是文本文件**             |
| /boot      | 存放内核和系统启动程序                                       |
| /usr       | 该目录最庞大，存放应用程序及相关文件                         |
| /dev       | 存放设备文件                                                 |
| /mnt       | 该目录主要用于存放系统引导后被挂载的文件系统的挂载点。       |
| **/root**  | **该目录用于存放根用户（超级用户）的主目录。**               |
| /lib       | 包含支持位于/bin和/sbin下的二进制文件的库文件。              |
| **/media** | **用于挂载可移动设备的临时目录。**                           |
| /srv       | srv代表服务，包含服务器特定服务相关的数据。                  |
| /proc      | 包含系统进程的相关信息                                       |
| /var       | 用于存放系统中经常变化的文件，如日志文件，用户邮件邮件等     |
| /tmp       | 公用的临时文件存储点                                         |

### 5.2工作目录切换命令

**1．pwd命令**
pwd命令用于显示用户当前所处的工作目录，pwd是print working directory的缩写。
命令格式为：“pwd [选项]”

**2．cd命令**
cd命令用于切换工作路径。
**语法格式：cd 目录路径**
可以通过cd命令迅速、灵活地切换到不同的工作目录。
cd后没有任何参数该命令直接回到用户主目录
使用**“cd ~”**命令切换到当前用户的家目录
使用**“cd ..”**命令进入上级目录
使用**“cd ~username”**切换到其他用户的家目录
可以使用**“cd -”**命令返回到上一次所处的目录

cd命令路径的表示
相对路径是以“.”或“..”开始的目录路径表示形式
```cd ./test```
绝对路径是以“/”开始的路径表示形式
```cd /home```

**3．ls命令**
所处的工作目录不同，工作目录下的文件肯定也不同，ls命令用于显示目录中的文件信息。
命令格式：ls [选项] [文件]
命令选项：
-t：按照修改时间排列显示
-a：看到全部文件（包括隐藏文件）
-l：可以查看文件的属性、大小等详细信息
将l和a参数整合之后，再执行ls命令即可查看当前目录中的所有文件并输出这些文件的属性信息。



Linux文件系统中的文件是数据的集合，文件系统不仅包含着文件中的数据而且还有文件系统的结构，所有Linux用户和程序看到的文件、目录、软连接及文件保护信息等都存储在其中。
**Linux中的设备、磁盘等所有信息均存在文本文件里。**
**Linux不使用文件名扩展来识别文件的类型。**
**Linux文件中以“.”开头的是隐藏文件。**
**Linux文件中以“~”结尾的是备份文件**

**Linux文件类型：**
1.普通文件（-）
2.目录（d）
3.字符设备文件（c）
4.块设备文件（b）
5.套接口文件（s）
6.管道（p）
7.符号链接文件（l）

## 6、文本文件编辑命令

### 6.1Linux文本文件介绍

Linux系统中“一切都是文件”，而对服务程序进行配置自然也就是编辑程序的配置文件。如果不能熟练地查阅系统或服务的配置文件，那以后工作就很难顺利开展。
文本文件在Linux中为了进行类型的区分，都带有不同的颜色。在Linux字符界面中输入了ls -l以后的文件列表中可以看到这些文本的颜色。

绿色文件：可执行文件，可执行的程序
红色文件：压缩文件或者包文件
蓝色文件：目录
白色文件：一般性文件，如文本文件，配置文件，源码文件等
浅蓝色文件：链接文件，主要是使用ln命令建立的文件
红色闪烁：表示链接的文件有问题
黄色：表示设备文件
灰色：表示其他文件

### 6.2Linux文本文件查看命令

**1．cat命令**
cat命令用于查看纯文本文件（内容较少的）。可以将整个文件的内容从上到下显示在屏幕上。
语法格式：```cat [-AbeEnstTuv] [--help] [--version] 文件名称```
常用选项：
-n或--number由1开始对所有输出的行数编号

直接在#提示符后面输入cat，会进入一个交互模式，输入什么内容回车后会显示什么内容。
Ctrl+c可以强制中断命令执行
Ctrl+d可以退出交互模式

#cat >file1.txt可以把内容写入到file1.txt文件中，也会进入输入模式。
Ctrl+d保存退出

**2．more命令**
more命令用于查看纯文本文件（内容较多的）
语法格式：```more [选项]文件```
more会以**一页一页**的显示方便使用者逐页阅读，而最基本的指令就是按**空白键（space）**就往下一页显示，按**回车键**就会向下滚动一行，按**b键**就会往回（back）一页显示，按**q键**停止显示，而且还有搜寻字串的功能。
more会进入一种全屏的查看状态，如果文档结束，会自动退出查看状态
例子：

```#more /etc/passwd```

**3．less命令**
less工具也是对文件或其它输出进行分页显示的工具，应该说是Linux正统查看文件内容的工具，功能极其强大。
使用了less时，就可以使用**[pageup][pagedown]**等按键的功能来往前往后翻看文件，更容易用来查看一个文件的内容！
除非用**q键**退出查看的状态，可以反复查看文件内容。
例子：

```#less /etc/passwd```

**4．head命令**
head命令的作用是显示文件的头部内容（默认10行）
语法格式：
```head [必要选项] [选择选项] [文件]```
常用选项：
-n 用数字来指定显示的行数。
实例：```#head -4 /etc/passwd```

5．tail命令
tail命令的作用是显示文件的尾部内容（默认10行）
语法格式：
```tail [必要选项] [选择选项] [文件]```
常用选项：
-n 用数字来指定显示的行数。
实例：```#tail -4 /etc/passwd```

### 6.3Linux文本文件编辑命令

**1．wc命令**
wc命令用于统计指定文本的行数、字数、字节数
语法格式：```wc [选项] 文本```
Linux系统中的wc命令用于统计文本的行数、字数、字节数等
常用选项：
-l只显示行数
-w只显示单词数
-c只显示字节数

**2．cut命令**
cut命令用于按“列”提取文本字符
命令格式：```cut [参数] 文本```
主要参数：
-b：以字节为单位进行分割。
-c：以字符为单位进行分割。
-d：自定义分隔符，默认为制表符。
-f：与-d一起使用，指定显示哪个区域。

**3．diff命令**
diff命令用于比较两个文件内容的不同。
语法格式：```diff [选项] 源文件 目标文件```
常用选项：
-y：以并列的方式显示文件的异同之处。
-b：忽略空格造成的不同。
-B：忽略空行造成的不同。
-q：只报告什么地方不同，不报告具体的不同信息。
-i：忽略大小写的变化。
-W：在使用-y参数时，指定栏宽。

## 7、文件目录管理命令

### 7.1Linux文件类型查看

**1、file命令**
file命令用于查看文件的类型，格式为“file 文件名”。
在Linux系统中，由于文本、目录、设备等所有这些一切都统称为文件，而我们又不能单凭后缀就知道具体的文件类型，这时就需要使用file命令来查看文件类型了。

### 7.2Linux文本管理命令

**1、touch命令**
touch命令用于创建空白文件或设置文件的时间。
命令格式：```touch [选项] 文件或目录名```
命令选项：
-d	“YYYYMMDD HH:mm:SS”：修改文件的修改/存取时间
实例：
创建一个空文件（文件原来不存在）
```#touch test```
把当前目录下的所有文件的存取和修改时间改为当前系统的时间。
```#touch *```
把文件chap1.txt的存取和修改时间改为2020年4月27日。
```#touch -d “20200427” chap1.txt```

### 7.3Linux目录管理命令

1．mkdir命令
mkdir命令用于创建空白的目录。除了能创建单个空白目录外，mkdir命令还可以结合-p参数来递归创建出具有嵌套叠层关系的文件目录。
命令格式：```mkdir [选项] <目录名>```
命令选项：-p：循环建立目录
实例：

```
# mkdir /d1
# mkdir /d1/d2
# mkdir –p /d3/d4
```



2．rmdir命令
删除目录（为空目录）
命令格式：```rmdir [选项] <目录名>```
命令选项：-p：循环删除目录
实例：

```
# rmdir ./a1
# rmdir /etc/a2
# rmdir -p /d1/d2
```



3．cp命令
拷贝文件或目录（相当于DOS下的copy命令）
命令语法：```cp [选项] 源文件 目标文件```
常用选项：
-r复制目录，如果目录存在，则提示。
-f或--force强行复制文件或目录，不论目的文件或目录是否已经存在
-i或--interactive　覆盖既有文件之前先询问用户。
-u或--update使用这项参数之后，只会在源文件的修改时间(Modification Time)较目的文件更新时，或是名称相互对应的目的文件并不存在，才复制文件
-p或--preserve　保留源文件或目录的属性。

实例：
```[root @localhost home]#cp /home/my/test /home/	```将test文件拷贝到home目录下

```[root @localhost home]#cp abc bbb```				将当前目录下的abc文件复制到当前目录下，更改名称为bbb

```[root @localhost home]#cp -r /home/my /	```				将my文件夹拷贝到根目录下

```[root @localhost home]#cp -p /home/my /root```		保留源文件的属性

4．rm命令
rm命令用于删除文件或目录。想要删除目录，需要在rm命令后面一个-r参数才可以，否
则删除不掉。
命令语法：```rm [选项] 目标文件```
常用选项：
-r或者-R将参数中列出的全部目录和子目录均递归地删除。
-f或--force　强制删除文件或目录，忽略不存在的文件，从不给出提示。
-i或--interactive　删除既有文件或目录之前先询问用户。**默认**

实例：
```[test @localhost test]$rm *```			删除当前目录下的所有文件，但子目录和以“.”开头的文件(即隐含文件)不删除。
```[test @localhost test]$rm –ir bak```		删除当前目录下的子目录bak，包含其下的所有文件和子目录，并且提示用户确认。
```[test @localhost test]$ rm –rf test```		强制性删除某个非空目录test，没有任何提示

5．mv命令
mv命令用于剪切文件或将文件重命名
命令语法：```mv [选项] 源文件 [目标路径|目标文件名]```
常用选项：
-f：不论目标文件或目录是否存在，均不提示是否覆盖目标文件或目录。

实例：
```[test @localhost test]$mv 1.txt 2.txt```	这里移动文件时并不改变文件的目录，如果2.txt原来不存在，则实际上是1.txt更名为2.txt
```[test @localhost test]$mv ~/txtbak /bak```	把个人主目录下的文件txtbak移动到/bak目录下

## 8.打包压缩与搜索命令

### 8.1Linux压缩格式介绍

了，它有.gz、.tar.gz、tgz、bz2、.Z、.tar等众多的压缩文件名，此外windows下的.zip和.rar也可以在Linux下使用，不过在Linux使用.zip和.rar的人就太少了。

**tar**是linux常见的一种归档文件，打包文件，不包括压缩的功能。他只消耗非常少的CPU
以及时间去打包文件。
**tar.gz**是linux中使用得最多的压缩格式，这种格式一般是先归档然后再压缩，它在压缩时
不会占用太多的cpu，而且压缩比率理想。
**tar.bz**2是linux中压缩率最好的压缩格式，但是，压缩率好就意味这要消耗更多的cpu时
间。

### 8.2Linux打包压缩命令

**1．tar命令**
tar命令用于对文件进行打包压缩或解压，tar命令可以把一系列的文件归档到一个大文件中，也可以把档案文件解开以恢复数据。
命令语法：```tar [选项] 档案文件 文件列表```
常用选项：
-c：生成档案文件。
-v：列出归档解档的详细过程。
-f：指定档案文件名称。
-r：将文件追加到档案文件末尾。
-z：以gzip格式压缩或解压缩文件。
-j：以bzip2格式压缩或解压缩文件。
-t：查看内容。
-x：解开档案文件。

实例一：将整个/etc 目录下的文件全部打包成为/tmp/etc.tar
```[root@linux ~]# tar -cvf /tmp/etc.tar /etc```　　　<==仅打包，不压缩！
```[root@linux ~]# tar -zcvf /tmp/etc.tar.gz /etc```　<==打包后，以 gzip 压缩
```[root@linux ~]# tar -jcvf /tmp/etc.tar.bz2 /etc```　<==打包后，以 bzip2 压缩

实例二：查阅上述/tmp/etc.tar.gz 文件内有哪些文件？
```[root@linux ~]# tar -ztvf /tmp/etc.tar.gz```

实例三：将/tmp/etc.tar.gz 文件解压缩在/usr/local/src 底下
```[root@linux ~]# cd /usr/local/src```
```[root@linux src]# tar -zxvf /tmp/etc.tar.gz```

### 8.3Linux搜索命令

**1．find命令**
命令语法：
```find pathname -options 参数```
（pathname: find命令所查找的目录路径）
选项参数：
-name按照文件名查找文件。
-user按照文件属主来查找文件
-group按照文件所属的组来查找文件。
查找过程可以使用通配符，*表示多位字符，？表示一位字符

实例一：
```[root @localhost /root]#find / -name passwd```
从根目录起查找名为passwd的文件，并把结果输出到标准设备。

```[root @localhost /root]#find /home /etc –user twelveeee```
在目录/home和目录/etc中查找twelveeee用户所拥有的文件。

实例二：
查找文件名中包含某字符（如"elm"）的文件
```find /home/ -name ‘*elm*‘```中间包含elm的文件
```find /home/ -name ‘elm*‘```以elm开头的文件
```find /home/ -name ‘*elm‘```以elm结尾的文件
```find /home/ -name ‘elm？'```以elm开头的4字符名称的文件

**2．grep命令**
grep命令用于在文本中执行关键词搜索，并显示匹配的结果。
命令语法：
```grep [参数] 要查找的字符串 文件名```
参数选项：
-v：反向选择，仅列出没有“关键词”的行。
-c：仅显示找到的行数
-i：不区分大小写。
-b：将可执行文件(binary)当作文本文件（text）来搜索
-n：每个匹配行只按照相对的行号显示。

**3．whereis命令**
whereis命令用来寻找命令的可执行文件所在的位置。
命令语法：```whereis [参数] 命令名称```
参数选项：
-b：只查找二进制文件。
-m：只查找命令的联机帮助手册部分。
-s：只查找源代码文件。

**4．whatis命令**
whatis命令whatis命令用于获取命令简介。
命令语法：```whatis 命令名称```

## 9、重定向与管道符

### 9.1 输入输出重定向

输入重定向是指把文件导入到命令中。
输出重定向则是指把原本要输出到屏幕的数据信息写入到指定文件中。
在日常的学习和工作中，相较于输入重定向，我们使用输出重定向的频率更高，所以又将输出重定向分为了标准输出重定向和错误输出重定向两种不同的技术，以及清空写入与追加写入两种模式。
**标准输入重定向**（STDIN，文件描述符为0）：默认从键盘输入
**标准输出重定向**（STDOUT，文件描述符为1）：默认输出到屏幕。
**错误输出重定向**（STDERR，文件描述符为2）：默认输出到屏幕。

| 类别                 | 操作符 | 说明                                                         |
| -------------------- | ------ | ------------------------------------------------------------ |
| 输入重定向           | <      | 输入重定向是将命令中接收输入的途径由默认的键盘更改（重定向）为指定的文件 |
| 输出重定向           | >      | 将命令的执行结果重定向输出到指定的文件中，命令进行输出重定向后执行结果将不显示在屏幕上 |
| 输出重定向           | >>     | 将命令执行的结果重定向并追加到指定文件的末尾保存             |
| 错误重定向           | 2>     | 清空指定文件的内容，并保存标准错误输出的内容到指定文件中     |
| 错误重定向           | 2>>    | 向指定文件中追加命令的错误输出，而不覆盖文件中的原有内容     |
| 输出与错误组合重定向 | &>     | 将标准输出与错误输出的内容全部重定向到指定文件               |
| 输出与错误组合重定向 | &>>    | 将标准输出与错误输出的内容全部以追加方式重定向到指定文件     |

输入重定向相对来说有些冷门，在工作中遇到的概率会小一点。输入重定向的作用是把文件直接导入到命令中。接下来使用输入重定向把readme.txt文件导入给wc -l命令，统计一下文件中的内容行数。
```[root@linuxprobe ~]# wc -l < readme.txt```

实例：
将命令输出重定向到文件:
将标准输出重定向到文件			```$ ls /etc/ > etcdir```
将标准输出重定向追加到文件	```$ ls /etc/sysconfig/ >> etcdir```
将错误输出重定向到文件			```$ nocmd 2> errfile```
将标准输出和错误输出重定向到文件	```$ ls afile bfile &> errfile```

### 9.2 管道符

管道命令符的作用也可以用一句话来概括“把前一个命令原本要输出到屏幕的标准正常数据当作是后一个命令的标准输入”，同时按下键盘上的Shift+\键即可输入管道符，其执行格式为“```命令A | 命令B|命令C|..```”。
这个管道符就像一个法宝，我们可以将它套用到其他不同的命令上，比如用翻页的形式查看/etc目录中的文件列表及属性信息。

### 9.3 命令行的通配符

通配符就是通用的匹配信息的符号，比如星号（*）代表匹配零个或多个字符，问号（?）代表匹配单个字符，中括号内加上数字[0-9]代表匹配0～9之间的单个数字的字符，而中括号内加上字母[abc]则是代表匹配a、b、c三个字符中的任意一个字符。

# 3.Linux文本编辑器

## 1.vim编辑器的基本操作

**1.1 文本编辑器介绍**

文本编辑器的作用:Linux系统中的配置文件以文本文件的形式保存,Linux管理员需要通过编辑配置文件进行系统管理
文本编辑器的分类:行编辑器与全屏幕编辑器,字符界面编辑器与图形界面编辑器
**vim**:Vim是一个高度可配置的、跨平台的、高效率的文本编辑器,大多数Linux系统中缺省使用的文本编辑器。
**Emacs**:用于编辑程序源代码文件的文本编辑器
**nano**:在字符界面提供了菜单操作，易用性较好
**gedit**:GNOME图形环境中的文本编辑器

**1.2 vim编辑器的三个模式**
命令模式：控制光标移动，可对文本进行复制、粘贴、删除和查找等工作
输入模式：正常的文本录入
末行模式：保存或退出文档，以及设置编辑环境

**1.3 vim编辑器的启动和退出**
vim编辑器的启动:
直接进入编辑环境`$ vi`
进入编辑环境并打开（新建）文件`$ vi myfile`
vim编辑器的退出:
退出vi编辑环境
`:q`退出
`:wq`保存退出
输入末行命令放弃对文件的修改，并退出编辑器`:q!`

**1.4 文件的打开和读取**
打开新文件:
打开新的文件到vi编辑器中`:e filename`
打开新的文件到vi编辑器中，并放弃对当前文件的修改`:e! filename`

读取其他文件:读取文件内容到当前vi编辑器中`:r filename`

**1.5 文件保存与另存为**

保存对vi编辑器中已打开文件的修改`:w`
将vi编辑器中的内容另存为指定文件名`:w myfile`

## 2.输入模式常见操作

**2.1 进入输入模式**
vim编辑器有三个模式，利用命令进入到vim编辑器中初始面对的是命令模式，命令模式无法对当前文件进行输入操作，必须进入输入模式才能进行文本的输入。进入的方法是按键盘上的i、a、o这几个键。

| 命令 | 功能                                                       |
| ---- | ---------------------------------------------------------- |
| i    | 在当前光标处进入插入状态                                   |
| a    | 在当前光标后进入插入状态                                   |
| A    | 将光标移动到当前行的行末，并进入插入状                     |
| o    | 在当前行的下面插入新行，光标移动到新行的行首，进入插入状态 |
| O    | 在当前行的上面插入新行，光标移动到新行的行首，进入插入状态 |

**2.2 输入模式的编辑操作**

| 按键      | 功能                       |
| --------- | -------------------------- |
| 方向键    | 进行上下左右方向的光标移动 |
| Home      | 快速定位光标到行首         |
| End       | 快速定位光标到行尾         |
| PageUp    | 进行文本的向上翻页         |
| PageDown  | 进行文本的向下翻页         |
| Backspace | 删除光标左侧的字符         |
| Del       | 删除光标位置的字符         |

## 3.命令模式常见操作

**3.1 命令模式的基本操作**
输入vi命令后,便进入全屏幕编辑环境,此时的状态为命令模式。在命令模式下，我们可以输入一些命令，但是当你点击键盘上相应键输入命令时，这些命令只会呈现最终的效果，不会在编辑器界面上显示出命令的字符。

**3.2 行内快速跳转**

| 操作键 | 功能                                                 |
| ------ | ---------------------------------------------------- |
| ^      | 将光标快速跳转到本行的行首字符home                   |
| $      | 将光标快速跳转到本行的行尾字符end                    |
| w      | 将光标快速跳转到当前光标所在位置的后一个单词的首字母 |
| b      | 将光标快速跳转到当前光标所在位置的前一个单词的首字母 |
| e      | 将光标快速跳转到当前光标所在位置的后一个单词的尾字母 |
| 方向键 | 进行上下左右方向的光标移动                           |
| Home   | 快速定位光标到行首                                   |
| End    | 快速定位光标到行尾                                   |

**3.3 行间快速跳转**

| 命令      | 功能                   |
| --------- | ---------------------- |
| :set nu   | 在编辑器中显示行号     |
| :set nonu | 取消编辑器中的行号显示 |
| 1G        | 跳转到文件的首行       |
| G         | 跳转到文件的末尾行     |
| #G        | 跳转到文件中的第#行    |
| PageUp    | 进行文本的向上翻页     |
| PageDown  | 进行文本的向下翻页     |

## 4.vim编辑器的删除与撤销

**4.1 文件内容的删除**

| 命令   | 功能                                                       |
| ------ | ---------------------------------------------------------- |
| x      | 删除光标处的单个字符=delete                                |
| **dd** | **删除光标所在行5dd可以删除5行内容**                       |
| dw     | 删除当前字符到单词尾（包括空格）的所有字符                 |
| de     | 删除当前字符到单词尾（不包括单词尾部的空格）的所有字符     |
| d$     | 删除当前字符到行尾的所有字符                               |
| d^     | 删除当前字符到行首的所有字符                               |
| J      | 删除光标所在行行尾的换行符，相当于合并当前行和下一行的内容 |

**4.2 文件内容的撤销**

| **命令**   | **功能**                                                     |
| ---------- | ------------------------------------------------------------ |
| **u**      | **取消最近一次的操作，并恢复操作结果可以多次使用u命令恢复已进行的多步操作** |
| U          | 取消对当前行进行的所有操作                                   |
| **Ctrl+r** | **对使用u命令撤销的操作进行恢复**                            |

## 5.vim编辑器的复制与粘贴

单行复制：在命令模式下，将光标移动到将要复制的行处，按“yy”进行复制；
多行复制：在命令模式下，将光标移动到将要复制的首行处，按“nyy”复制n行；其中n为数字。
粘贴：在命令模式下，将光标移动到将要粘贴的行处，按“p”进行粘贴

| 命令 | 功能                                                         |
| ---- | ------------------------------------------------------------ |
| yy   | **复制当前行整行的内容到vi缓冲区5yy从当前行开始复制5行**     |
| yw   | 复制当前光标到单词尾字符的内容到vi缓冲区                     |
| y$   | 复制当前光标到行尾的内容到vi缓冲区                           |
| y^   | 复制当前光标到行首的内容到vi缓冲区                           |
| p    | **读取vi缓冲区中的内容，并粘贴到光标当前的位置（不覆盖文件已有的内容）** |

## 6.vim编辑器的查找与替换

**6.1 文件内容的查找**
vi提供了几种定位查找一个指定的字符串在文件中位置的方法。同时还提供一种功能强大的全局替换功能。
为查找一个字符串，在vi命令模式下键入“/”，后面跟要查找的字符串，再按回车。vi将光标定位在该串下一次出现的地方上。键入n跳到该串的下一个出现处，键入N跳到该串的上一个出现处。

| 命令      | 功能                                 |
| --------- | ------------------------------------ |
| **/word** | **从上而下在文件中查找字符串“word”** |
| **?word** | **从下而上在文件中查找字符串“word”** |
| **n**     | **定位下一个匹配的被查找字符串**     |
| N         | 定位上一个匹配的被查找字符串         |

**6.2 文件内容的替换**

| 命令              | 功能                                                      |
| ----------------- | --------------------------------------------------------- |
| :s/old/new        | 将当前行中查找到的第一个字符“old”串替换为“new”            |
| :s/old/new/g      | 将当前行中查找到的所有字符串“old”替换为“new”              |
| :#,#s/old/new/g   | 在行号“#,#”范围内替换所有的字符串“old”为“new”             |
| **:%s/old/new/g** | **在整个文件范围内替换所有的字符串“old”为“new”**          |
| :s/old/new/c      | 在替换命令末尾加入c命令，将对每个替换动作提示用户进行确认 |



# 4.用户身份与文件权限

## 1.Linux用户身份介绍

**1.1 Linux用户介绍**
Linux下的用户可以分为三类：超级用户、系统用户和普通用户。每个用户都有一个数值，称为UID。

| 昵称         | 权限                                                         | 功能                                                         | UID        |
| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ---------- |
| 超级用户root | 具有一切权限                                                 | 管理系统的各项功能，如添加/删除用户、启动/关闭服务进程、开启/禁用硬件设备 | 0          |
| 系统用户     | 为了满足相应的系统进程对文件属主的要求而建立的系统用户不能用来登录 | Linux系统正常工作所必需的内建的用户，例如：bin、daemon、adm、lp等 | 1~999      |
| 普通用户     | 由管理员赋予的一般权限                                       | 由管理员创建的用于日常工作的用户                             | 从1000开始 |

**1.2 Linux用户相关文件**
用户帐号信息保存在passwd文件中:/etc/passwd
用户的加密口令保存在shadow文件中:/etc/shadow
用户的宿主目录是home目录中与用户名称相同的目录:/home/teacher
用户的初始配置文件来在skel目录（配置模版）:/etc/skel
**1.3 passwd文件介绍**
/etc/passwd文件每一行都表示的是一个用户的信息；一行有7个段位；每个段位用:号分割。
`root:x:0:0:root:/root:/bin/bash`

`账号名称：密码：UID：GID：个人资料：主目录：Shell`

第一字段：用户名（也被称为登录名）
第二字段：口令；在例子中我们看到的是一个x，其实密码已被映射到/etc/shadow文件中
第三字段：UID；用户ID
第四字段：GID；用户组的ID
第五字段：用户名全称，这是可选的
第六字段：用户的家目录所在位置；root这个用户的家目录是/root
第七字段：用户所用SHELL的类型，root用的是bash；所以设置为/bin/bash
**1.4 shadow文件介绍**
Shadow文件一共有9个字段来表示跟密码有关的部分，每个字段用“：”来分隔。
`用户名：密码：最后一次修改时间：最小时间间隔：最大时间间隔：警告时间：不活动时间：失效时间：标志字段说明`
`bin:*:17110:0:99999:7:::`
用户名：和/etc/passwd文件中相对应的用户名。
密码：存放加密后的口令(密码)。密码字段为“*”表示用户被禁止登录，为“！！”表示密码未设置，为“！”表示用户被锁定。
最后一次修改时间：用户最后一次修改口令的时间(从1970-1-1起计的天数)。
最小时间间隔：两次修改口令允许的最小天数。
最大时间间隔：口令保持有效的最多天数，即多少天后必须修改口令。
警告时间：从系统提前警告到口令正式失效的天数。
不活动时间：口令过期多少天后，该账号被禁用。
失效时间：指示口令失效的绝对天数(从1970-1-1开始计算)。
标志：未使用。

**1.5 group文件介绍**
Linux系统关于组的信息存放在文件/etc/group中.Linux的组有私有组、系统组、标准组之分。私有组:建立账户时，若没有指定账户所属的组，系统会建立一个组名和用户名相同的组，这个组就是私有组，这个组只容纳了一个用户。标准组:可以容纳多个用户，组中的用户都具有组所拥有的权利。系统组:Linux系统正常运行所必需的，安装Linux系统或添加新的软件包会自动建立系统组。
`root:x:0:`
`组名：组的密码：GID：组成员`
注：组的密码：设置加入组的密码，一般情况下不使用组密码，该字段通常没用

## 2.创建Linux用户

**2.1 添加Linux用户**
**adduser/useradd**:
创建用户,使用该命令创建用户账户时，默认的用户家目录会被存放在/home目录中，默认的Shell解释器为/bin/bash，而且默认会创建一个与该用户同名的基本用户组。
语法格式：`useradd [选项] 用户名`
常用选项：
-e账户的到期时间，格式为YYYY-MM-DD
-u指定该用户的默认UID
-d指定用户的家目录（默认为/home/username）
-g指定一个初始的已存在用户基本组
-G指定一个或多个扩展用户组
-N不创建与用户同名的基本用户组
-s指定该用户的默认Shell解释器

**2.2 设置Linux用户密码**
**passwd命令**:
用于修改用户密码、过期时间、认证信息等
普通用户只能使用passwd命令修改自身的系统密码，而root管理员则有权限修改其他所有人的密码。更酷的是，root管理员在Linux系统中修改自己或他人的密码时不需要验证旧密码，这一点特别方便。
语法格式：`passwd [选项] [用户名]`
常用选项：
-d使该用户可用空密码登录系统
-l锁定用户，禁止其登录
-u解除锁定，允许用户登录
-S显示用户的密码是否被锁定，以及密码所采用的加密算法名称

## 3.管理Linux用户

**3.1 设置Linux用户账号**
**usermod命令**:
usermod命令用于修改用户的属性
语法格式：`usermod [选项] 用户名`
用户的信息保存在/etc/passwd文件中，可以直接用文本编辑器来修改其中的用户参数项目，也可以用usermod命令修改已经创建的用户信息，诸如用户的UID、基本/扩展用户组、默认终端等。
常用选项：
-g变更所属用户组
-G变更扩展用户组
-L锁定用户禁止其登录系统
-U解锁用户，允许其登录系统

| 选项          | 功能                                                         |
| ------------- | ------------------------------------------------------------ |
| -c comment    | 改变用户的注释，如：全名、地址、办公室电话、家庭电话等       |
| -d dir        | 改变用户的主目录                                             |
| -e YYYY-MM-DD | 修改用户的有效日期                                           |
| -L            | 锁定用户密码，使密码无效                                     |
| -U            | 解除密码锁定                                                 |
| -f days       | 在密码到期的days天后停止使用账户                             |
| -g GID或组名  | 修改用户的所属基本组                                         |
| -l name       | 更改账户的名称，必须在该用户未登录的情况下才能使用           |
| -p 密码       | 修改用户的密码                                               |
| -s Shell      | 修改用户的登录Shell                                          |
| -u UID        | 改变用户的UID为新的值，改变用户的UID时主目录下所有该用户所拥有的文件或子目录将自动更改UID，但对于主目录之外的文件和目录只能用chown命令手工进行设置 |

**3.2 删除Linux用户账号**
**userdel命令**:
userdel命令用于删除用户
语法格式：`userdel [选项] 用户名`
如果我们确认某位用户后续不再会登录到系统中，则可以通过userdel命令删除该用户的所有信息。在执行删除操作时，该用户的家目录默认会保留下来，此时可以使用-r参数将其删除。
常用选项：
-f强制删除用户
-r删除用户时将用户主目录下的所有内容一并删除，同时删除用户的邮箱，对于用户在别的目录下所拥有的文件只能手工删除

## 4.创建与管理Linux用户组

**4.1 创建Linux用户组**
**groupadd命令**:
groupadd命令用来添加用户
语法格式：`groupadd [选项] 群组名`
为了能够更加高效地指派系统中各个用户的权限，在工作中常常会把几个用户加入到同一个组里面，这样便可以针对一类用户统一安排权限。
常用选项：
-g GID指定新组的GID，默认值是已有的最大的GID加1
-r建立一个系统专用组，与-g不同时使用时，则分配一个1～999的GID
例子：
`[root @localhost /root]#groupadd -g 1000 group1`表示添加一个新组，组ID为1000，组名为group1

**4.2 管理Linux用户组**
**groupmod命令**:
groupmod命令用于修改组的属性
语法格式：`groupmod [选项] 群组名`
常用选项：
-g GID指定组新的GID
-n name更改组的名字为name

**4.3 删除Linux用户组**
**groupdel命令**：
删除指定名称的用户组帐号
语法格式：`groupdel 群组名`
需要从系统上删除群组时，可用groupdel指令来完成这项工作。倘若该群组中仍包括某些用户，则必须先删除这些用户后，方能删除群组。

## 5.文件的权限与归属

**5.1 查看文件的权限与归属**
尽管在Linux系统中一切都是文件，但是每个文件的类型不尽相同，因此Linux系统使用了不同的字符来加以区分，常见的字符如下所示。

| 代码 | 文件类型     |
| ---- | ------------ |
| -    | 普通文件     |
| d    | 目录文件     |
| l    | 链接文件     |
| b    | 块设备文件   |
| c    | 字符设备文件 |
| p    | 管道文件     |

`-rw-r--r--`

| 权限项   | 读         | 写         | 执行       | 读             | 写             | 执行           | 读       | 写       | 执行     |
| -------- | ---------- | ---------- | ---------- | -------------- | -------------- | -------------- | -------- | -------- | -------- |
| 字符表示 | r          | w          | x          | r              | w              | x              | r        | w        | x        |
| 数字表示 | 4          | 2          | 1          | 4              | 2              | 1              | 4        | 2        | 1        |
| 权限分配 | 文件所有者 | 文件所有者 | 文件所有者 | 文件所属组用户 | 文件所属组用户 | 文件所属组用户 | 其他用户 | 其他用户 | 其他用户 |

**5.2 修改文件的权限**
**chmod命令**：
用于更改文件对于某类用户的操作权限
`chmod [ugoa...][[+-=][rwx] FILE...`
设置权限的对象，可以是用户、组、其他人或所有人|属性操作符+增加权限-减少权限=设置权限为|权限内容，可以是读、写、执行权限的组合|被设置属性的文件或目录
例子：`-rw-rw-r-- 1 st01 class1 0 Apr 3 16:52 afile`
增加文件属主st01的执行权限（x）`# chmod u+x afile`
去除文件属组class1的写权限（w）`# chmod g-w afile`
设置其他用户的文件权限为可执行`# chmod o=x afile`
设置用户拥有执行权限，其他用户拥有写入权限`#Chmod u+x,o+w afile`
设置用户和用户组拥有执行的权限`#Chmod ug+x afile`

增加文件属主st01的执行权限（x）`# chmod 764 afile`
去除文件属组class1的写权限（w）`# chmod 644 afile`

**5.3 修改文件的归属**
要想改变一个文件对某些用户的权限，除了可以修改它的权限之外，还有一个方案就是修改文件属于哪个用户和用户组。
**chown命令**：
用于设置文件的属主和属组
命令格式:`chown OWNER[:[GROUP]] FILE...`
例子:
设置文件afile的属主为用户st01`# chown st01 afile`
设置文件afile的属主为st03，并设置文件的属组为class2 `# chown st03:class2 afile`
设置文件afile的属组为用户组class1`# chown :class1 afile`

## 6.文件的特殊权限

特殊权限：在复杂多变的生产环境中，单纯设置文件的rwx权限无法满足我们对安全和灵活性的需求，因此便有了SUID、SGID与SBIT的特殊权限位。这是一种对文件权限进行设置的特殊功能，可以与一般权限同时使用，以弥补一般权限不能实现的功能。

**6.1 SUID特殊权限介绍**
**SUID**
对应user的权限位置：当s这个标志出现在文件所有者的x权限上时，例如文件权限状态`-rwsr-xr-x`，此时就称为Set UID，简称为SUID的特殊权限。
SUID有这样的限制和功能：
SUID权限仅对二进制程序有效；
执行者对于该程序需要具有x的可执行权限；
本权限仅在执行该程序的过程中有效；
执行者将具有该程序所有者的权限。

**6.2 SGID特殊权限介绍**
**SGID**
对应group权限位置:当s标志出现在文件所有者的x权限时称为SUID，那么s出现在用户组的x权限时称为SGID。（U表示user，G表示group）。
SGID有如下功能：
让执行者临时拥有属组的权限（对拥有执行权限的二进制程序进行设置）；
在某个目录中创建的文件自动继承该目录的用户组（只可以对目录进行设置）。
SGID的第一种功能是参考SUID而设计的，不同点在于执行程序的用户获取的不再是文件所有者的临时权限，而是获取到文件所属组的权限。

**6.3 SBIT特殊权限介绍**
**SBIT**
对应other用户权限位置
SBIT（Sticky Bit）特殊权限位（特殊权限位之粘滞位）。SBIT特殊权限位可确保用户只能删除自己的文件，而不能删除其他用户的文件。换句话说，当对某个目录设置了SBIT粘滞位权限后，那么该目录中的文件就只能被其所有者执行删除操作了。SBIT目前只对目录有效。
RHEL7系统中的/tmp作为一个共享文件的目录，默认已经设置了SBIT特殊权限位，因此除非是该目录的所有者，否则无法删除这里面的文件。

## 7.文件的隐藏属性

隐藏属性：Linux系统中的文件除了具备一般权限和特殊权限之外，还有一种隐藏权限，即被隐藏起来的权限，默认情况下不能直接被用户发觉。有用户曾经在生产环境中碰到过明明权限充足但却无法删除某个文件的情况，或者仅能在日志文件中追加内容而不能修改或删除内容，这在一定程度上阻止了黑客篡改系统日志的图谋，因此这种“奇怪”的文件也保障了Linux系统的安全性。

**7.1 chattr命令**
**chattr命令**
用于设置文件的隐藏权限
命令格式：`chattr [选项] 文件`
如果想要把某个隐藏功能添加到文件上，则需要在命令后面追加“+参数”，如果想要把某个隐藏功能移出文件，则需要追加“-参数”。
常用选项
i无法对文件进行修改；若对目录设置了该参数，则仅能修改其中的子文件内容而不能新建或删除文件.
a仅允许补充（追加）内容，无法覆盖/删除内容（Append Only）

**7.2 lsattr命令**
**lsattr命令**用于显示文件的隐藏权限，在Linux系统中，文件的隐藏权限必须使用lsattr命令来查看，平时使用的ls之类的命令则看不出端倪。
命令格式：`lsattr [选项] 文件`
一旦使用lsattr命令后，文件上被赋予的隐藏权限马上就会原形毕露。此时可以按照显示的隐藏权限的类型（字母），使用chattr命令将其去掉。

## 8.su命令与sudo服务

**8.1 su命令**
su命令可以解决切换用户身份的需求，使得当前用户在不退出登录的情况下，顺畅地切换到其他用户，比如从root管理员切换至普通用户。
su命令与用户名之间有一个减号（-），这意味着完全切换到新的用户，即把环境变量信息也变更为新用户的相应信息，而不是保留原始的信息。
当从root管理员切换到普通用户时是不需要密码验证的，而从普通用户切换成root管理员就需要进行密码验证了。

**8.2 sudo服务**
使用sudo命令把特定命令的执行权限赋予给指定用户，这样既可保证普通用户能够完成特定的工作，也可以避免泄露root管理员密码。sudo服务的配置原则也很简单：在保证普通用户完成相应工作的前提下，尽可能少地赋予额外的权限。
这个服务是通过修改配置文件（/etc/sudoers）来提供集中的用户管理、权限与主机等设置，root用户可以通过visudo来修改这个配置文件。

**sudo服务的工作过程**
1，当用户执行sudo时，系统会主动寻找/etc/sudoers文件，判断该用户是否有执行sudo的权限
2，确认用户具有可执行sudo的权限后，让用户输入用户自己的密码确认
3，若密码输入成功，则开始执行sudo后续的命令
4，root执行sudo时不需要输入密码(sudoers文件中有配置root ALL=(ALL) ALL这样一条规则)
5，若欲切换的身份与执行者的身份相同，也不需要输入密码

第一步：
利用visudo为指定用户添加权限
`[root@localhost ~]# visudo`
关于root用户权限完整格式：
`root ALL=(ALL:ALL) ALL`
root表示能使用sudo命令的用户；
第一个ALL表示允许使用sudo的主机；
第二个ALL及第三个ALL表示用户组及用户；
第四个ALL表示sudo可执行的命令，即所有命令；
第二步：
利用visudo修改了配置以后，切换至指定的普通用户身份，此时就可以用sudo -l命令查看到所有可执行的命令了，此处注意输入的是普通用户的密码。

使用sudo命令来执行特殊的权限
**sudo命令**用于给普通用户提供额外的权限来完成原本root管理员才能完成的任务
命令格式`sudo [选项] 命令名称`
常用选项:
-h列出帮助信息
-l列出当前用户可执行的命令
-u用户名或UID值以指定的用户身份执行命令

第三步：使用sudo命令来执行特殊的权限对于普通用户无权查看的shadow文件，利用sudu命令就可以获得权限进行查看。

# 5.Linux系统的日常运维

## 1.RPM软件包管理

**1.1 RPM软件包介绍**
RPM是RPM Package Manager（RPM软件包管理器）的缩写，这一文件格式名称虽然打上了RedHat的标志，但是其原始设计理念是开放式的，现在包括OpenLinux、SuSE以及 Turbo Linux等Linux的分发版本都有采用，可以算是公认的行业标准了。
RPM软件包的文件名：
`bash-3.0-19.2.i386.rpm`
名称-版本号-运行硬件平台-扩展名

RPM命令可以完成对软件包的所有管理功能：
查询已安装在Linux系统中的RPM软件包的信息
查询RPM软件包安装文件的信息
安装RPM软件包到当前Linux系统
从当前Linux系统中卸载已安装的RPM软件包
升级当前Linux系统中已安装的RPM软件包

**1.2 RPM软件包查询**

| 命令              | 功能                                 |
| ----------------- | ------------------------------------ |
| rpm -qa           | 查询Linux系统中的所有软件包          |
| rpm -q 包名称     | 查询指定名称的软件包是否安装         |
| rpm -qi 包名称    | 查询指定名称软件包的详细信息         |
| rpm -ql 包名称    | 查询指定名称软件包中所包括的文件列表 |
| rpm -qf 文件名称  | 查询指定文件所属的软件包             |
| rpm -qpi 包文件名 | 查询指定RPM包文件的详细信息          |
| rpm -qpl 包文件名 | 查询指定RPM包中包含的文件列表        |

**挂载：**
在Linux操作系统中，安装光盘中存在许多软件包，但是如何查看光盘中的内容呢？ Linux中有一个特殊的行为叫做挂载，挂载是指将一个设备(通常是存储设备)挂接到一个已存在的目录上。我们要访问存储设备中的文件，必须将文件所在的分区挂载到一个已存在的目录上，然后通过访问这个目录来访问存储设备。
挂载光盘使用mount命令:
`mount -t 光盘内容类型 设备文件路径 挂载点路径`
`# mount -t iso9660 /dev/cdrom /media`
注意：挂载完成后可以使用mount命令查看挂载情况
`umount /dev/cdrom`或者` umount 挂载点路径`可以卸载光盘

**查询系统中已安装的软件包信息:**
查询vim软件包有没有安装`$ rpm –qa|grep vim `
查询所有安装的软件包中以htt开头的软件包:`$ rpm –qa|grep ‘^htt’`

**1.3 RPM软件包安装**
rpm命令配合“-i”选项用于安装RPM软件包
`rpm -i bind-9.8.2-0.17.rc1.el6_4.6.i686.rpm`
命令名|-i选项表示安装软件包|要安装的软件包文件名作为命令参数
rpm命令配合“-ivh”在安装RPM软件包时会显示更多的提示信息：
-i （install）安装
-v （verbose）显示详细信息
-h (hash)显示进度

**依赖：**
RPM软件包在进行安装的时候容易出问题，主要是包与包之间有依赖关系。依赖包的产生，是因为linux软件采用共享资源库的方式，可以减少软件编程的开发量，类似于windows 下的各种库，高手可自行使用相关命令或方式查看软件包依赖。

**1.4 RPM软件包卸载与升级**
rpm命令配合“-e”选项用于卸载RPM软件包
`rpm -e bind-chroot`
命令名|-e选项表示卸载软件包|要卸载的软件包名称作为命令参数
rpm软件包的卸载同样存在依赖关系,被依赖的软件包应该最后被卸载

rpm命令配合“-U”选项用于升级RPM软件包
`rpm -U vim-enhanced-7.4.160-2.el7.i386.rpm`
命令名|-U选项表示升级软件包|升级的软件包文件名称作为命令参数
当系统中未安装需要升级的软件包时，升级的过程等同于安装软件包的过程.

## 2.YUM软件仓库

**2.1 YUM软件仓库介绍**
Yum是一个shell前端软件包管理器，基于RPM包管理，能够从指定的服务器自动下载 RPM包并安装，可以自动处理依赖关系，并且一次安装所有依赖的软件包。要成功的使用YUM 工具安装更新软件或系统，就需要有一个包含各种rpm软件包的repository（软件仓库），这个软件仓库我们习惯称为yum源。
网络上有大量的yum源，但由于受到网络环境的限制，导致软件安装耗时过长甚至失败。因此我们在优化系统时，都会更换国内的源。本地YUM源服务器最大优点是局域网的快速网络连接和稳定性。有了局域网中的YUM源服务器，即便在Internet连接中断的情况下，也不会影响其他YUM客户端的软件安装和升级

**2.2 配置YUM软件仓库**
配置本地YUM软件仓库，主要通过光盘镜像中的软件包作为本地的源，主要步骤有：
步骤一：挂载光盘镜像
步骤二：配置本地YUM软件仓库
步骤三：测试YUM软件仓库

步骤一：挂载光盘镜像
挂载光盘使用mount命令
` mount -t 光盘内容类型 设备文件路径 挂载点路径`
`# mount -t iso9660 /dev/cdrom /media`

步骤二：配置本地YUM软件仓库
在/etc/yum.repos.d/目录中存放的是yum的配置文件，可以在此目录下使用vi创建一个配置文件设置本地YUM软件仓库。
仓库配置文件:/etc/yum.repos.d/name.repo
[name]：仓库id name ：仓库名字
baseurl：为仓库的地址，本地文件file://,ftp文件地址ftp://
 gpgcheck：是否使用密钥验证
enable：是否开启当前仓库
gpgkey：公钥地址，若是需要检查完整性的话可以添加密钥地址

步骤三：测试YUM软件仓库
yum repolist : 显示软件仓库列表
yum list :显示软件包列表

**2.3 YUM软件仓库的使用**
Yum软件仓库的使用主要依靠yum相关命令，使用yum命令可以进行软件包的安装和管理。
安装：yum install package1 package2...
重新安装：yum reinstall package 
卸载：yum remove package 
更新：yum update package 
已安装的软件包：yum list installed 
查看软件包信息：yum info 软件包名称
例子：
安装zip软件包：`yum –y install zip`（-y可以自动回答yes）
卸载zip软件包：` Yum remove zip `
在已安装的软件包中查找vim相关软件包：`Yum list installed |grep “vim”`

## 3.服务和运行目标管理

**3.1 Linux的启动过程**
Linux操作系统的开机过程是这样的，即从BIOS开始，然后进入Boot Loader，再加载系统内核，然后内核进行初始化，最后启动初始化进程。初始化进程作为Linux系统的第一个进程，它需要完成Linux系统中相关的初始化工作，为用户提供合适的工作环境。Centos 7系统已经替换掉了熟悉的初始化进程服务System V init，正式采用全新的systemd初始化进程服务。
Systemd是一个系统管理守护进程、工具和库的集合，用于取代System V初始进程。 Systemd的功能是用于集中管理和配置类UNIX系统。

1.uefi或BIOS初始化，开始post开机自检
2.加载mbr到内存
3.GRUB阶段
4.加载内核和inintamfs模块
5.内核开始初始化，使用systemd来代替centos6以前的init程序
(1)执行initrd.target 
(2)从initramfs根文件系统切换到磁盘根目录
(3)systemd执行默认target配置
(4)systemd执行sysinit.target
(5)systemd启动multi-user.target下的本机与服务器服务
(6)systemd执行multi-user.target下的/etc/rc.d/rc.local
6.Systemd执行multi-user.target下的getty.target及登录服务
7.systemd执行graphical需要的服务

通过pstree命令可以查看进程树，能够看到现在的centos 7版本的Linux是由systemd进行启动管理的。

**3.2 Linux的运行目标**
Linux功能强大，为了适应不同用户对服务的启动配置要求，早期版本的Linux提供了运行级别，centos 7版本加入了systemd进行启动的管理，**systemd 用目标（target）替代了运行级别的概念**，提供了更大的灵活性，如您可以继承一个已有的目标，并添加其它服务，来创建自己的目标。

| Sysvinit 运行级别 | Systemd 目标          | 备注                                                         |
| ----------------- | --------------------- | ------------------------------------------------------------ |
| 0                 | poweroff.target       | 关闭系统                                                     |
| 1                 | rescue.target         | 单用户模式                                                   |
| 2                 | multi-user.target     | 用户定义/域特定运行级别。默认等同于3                         |
| **3**             | **multi-user.target** | **多用户，非图形化。用户可以通过多个控制台或网络登录**       |
| 4                 | multi-user.target     | 用户定义/域特定运行级别。默认等同于3                         |
| **5**             | **graphical.target**  | **多用户，图形化。通常为所有运行级别3 的服务外加图形化登录** |
| 6                 | reboot.targe          | 重启                                                         |

在centOS7上如何查看运行的目标呢，使用命令systemctl get-default 可以查看。
Systemctl是一个systemd工具，主要负责控制systemd系统和服务管理器。
runlevel也可以用来查看当前的运行级别。

**3.3 修改Linux的运行目标**
针对Linux的运行的目标，我们可以进行设置，设置时候用到了systemctl命令。
**临时修改运行级别**：从multi-user.target（即字符界面）改为graphical.target(即图形界面)
`systemctl isolate runlevel5.target`
**修改默认的运行级别**：systemd 使用链接来指向默认的运行级别。在创建新的链接前，你可以通过下面命令删除存在的链接，然后创建一个新的链接。
`rm /etc/systemd/system/default.target `
切换到运行级3 ：`ln -sf /lib/systemd/system/multi-user.target etc/systemd/system/default.target`

**3.4 Linux的服务**
**服务：是指执行指定系统功能的程序、例程或进程，**以便支持其他程序，尤其是底层(接近硬件)程序。例如：打印服务，ftp服务，http服务。
服务就是一个程序（正在执行的程序），是一个用来等待并处理请求的程序。
所有被激活的服务可以用下面这条命令来查看。
`systemctl list-units -t service`
查看所有启动文件：`systemctl list-unit-files`

**3.5 管理Linux服务**
Linux服务的管理包括控制服务的启动、查询、停止。以httpd.service (web服务)为例，说明服务的管理方法。

| 任务                   | 指令                            |
| ---------------------- | ------------------------------- |
| 使某服务开机自动启动   | systemctl enable httpd.service  |
| 使某服务开机不自动启动 | systemctl disable httpd.service |
| 检查服务状态           | systemctl status httpd.service  |
| 启动某服务             | systemctl start httpd.service   |
| 停止某服务             | systemctl stop httpd.service    |
| 重启某服务             | systemctl restart httpd.service |

## 4.Linux进程管理

**4.1 什么是进程**
进程：开始执行但是还没有结束的程序的实例
程序：包含可执行代码的文件
进程与程序的关系:
进程由程序产生，是一个运行着的、要占系统资源的程序
进程不等于程序
进程与程序是多对一
进程是占用（消耗）系统资源的

**4.2 查看进程**
显示进程信息:ps命令显示某时刻系统进程的状态信息
显示进程状态:top命令以全屏幕的方式显示系统中的进程状态，并定时刷新显示的内容,可以通过top命令查看系统中进程的动态变化.
显示系统进程树:pstree命令以树的形式显示系统进程间的父子关系

**ps命令**：显示某时刻系统进程的状态信息
常用选项：
a 显示现行终端机下的所有进程，包括其他用户的进程。
u 　以用户为主的格式来显示进程状况。
x 　显示所有进程，不以终端机来区分。

`USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND`
USER: 进程拥有者
PID: pid
%CPU:占用的cpu使用率
VSZ:占用的内存使用率
RSS:占用的虚拟内存大小
TTY:是否为登入者执行的程序
STAT:程序的状态:
R:正在执行中，S：睡眠，T：正在检测或者停止，Z：死亡程序，< 高优先级，N 低优先级，L 有些页被锁进内存，s 包含子进程，+位于后台的进程组；l 多线程，克隆线程
START:程序开始时间
TIME:程序运行的时间
COMMAND：所执行的指令。

**top命令**：动态显示进程状态
top命令以全屏幕的方式显示系统中的进程状态，并定时刷新显示的内容
第一行：显示系统已启动的时间、目前上线人数、系统整体的负载(load)。比较需要注意的是系统的负载，三个数据分别代表1,5,10 分钟的平均负载。一般来说，这个负载值应该不太可能超过1 才对，除非您的系统很忙碌。如果持续高于5 的话，那么.....仔细的看看到底是那个程序在影响整体系统吧！
第二行：显示的是目前的观察程序数量，
第三行：显示的是 CPU 的整体负载，每个项目可使用? 查阅。需要观察的是 id (idle)的数值，一般来说，他应该要接近100%才好，表示系统很少资源被使用啊！
第四行与第五行：表示目前的物理内存与虚拟内存(Mem/Swap)的使用情况。
第六行：这个是当在 top 程序当中输入指令时，显示状态的地方。

`PID USER PR NI VIRT RES SHR S %CPU SHR S %CPU %MEN TIME+ COMMAND`
PID ：每个 process 的 ID 啦！
USER：该 process 所属的使用者；
PR ：Priority 的简写，程序的优先执行顺序，越小越早被执行；
NI ：Nice 的简写，与 Priority 有关，也是越小越早被执行；
%CPU：CPU 的使用率；
%MEM：内存的使用率；
TIME+：CPU 使用时间的累加；
SHR:共享内存大小，单位kb
RES：进程使用的、未被换出的物理内存大小，单位kb

**pstree命令**：显示系统进程树
pstree命令以树的形式显示系统进程间的父子关系
需要安装psmisc软件包

**4.3 进程的启动方式**
手工启动:
由用户输入命令，直接执行一个程序
前台启动是普通的命令执行方式
后台启动需要在命令尾加入“&”
`# cp /dev/cdrom mycd.iso &`
调度启动
使用at命令设置某个命令在某个时间，一次性的在系统中执行
crontab命令设置在系统中需要周期性（如每天、每周等）完成的任务

**4.4 进程的控制**
把当前终端中运行的进程调入后台:使用“Ctrl+z”组合键可以将当前终端的进程调入后台并停止执行
查看后台的进程：
jobs命令用于查看当前终端中后台的所有进程的状态
`$ jobs`
`[1]+ Stopped top`
将后台的进程恢复到前台运行：
fg命令用于将后台的进程调入终端前台执行
`$ fg 1`

**kill命令**：终止正在执行的命令
使用“Ctrl + c”组合键可以强制结束当前终端中运行的命令
使用kill命令终止进程
`$ kill -9 2501`
命令名|-9命令选项表示强制终止进程|命令参数，需要终止运行的进程的进
程号（可通过ps命令查询到）

## 5.Linux计划任务管理

**5.1 cron服务介绍**
cron是一个可以用来根据时间、日期、月份、星期的组合来调度对周期性任务执行的守护进程。
利用cron所提供的功能，可以将需要周期性重复执行的任务设置为cron任务，并且设置为在主机较空闲的时间（如夜间）自动完成。

**5.2 管理cron服务**
查询crond服务状态:`# systemctl status crond.service`
停止crond服务`# systemctl stop crond.service`
启动crond服务`# systemctl start crond.service `
重新启动crond服务`# systemctl restart crond.service `
查看crond服务的开机启动状态`# systemctl list-units -t service |grep “crond”`

**5.3 配置cron服务**
cron服务的配置主要使用crontab命令。cron服务在配置的时候是基于当前用户的，不同的用户cron任务的存储文件也不同。
查看用户的cron任务: `# crontab -l `
调用文本编辑器对cron任务进行编辑: `# crontab -e `
编辑用户的cron任务:`# crontab -u user名称 - e `
删除用户现有的cron任务:`# crontab -r`

`50 3 2 1 * run_yearly_cmd`
minute|hour|day|month|dayofweek|command

| 字段      | 说明                                             |
| --------- | ------------------------------------------------ |
| minute    | 分钟，取值为从0到59之间的任意整数                |
| hour      | 小时，取值为从0到23之间的任意整数                |
| day       | 日期，取值为从1到31之间的任意整数                |
| month     | 月份，取值为从1到12之间的任意整数                |
| dayofweek | 星期，取值为从0到7之间的任意整数，0或7代表星期日 |
| command   | 要执行的命令或程序脚本                           |

时间的设置上还有一些特殊的符号能够起到灵活的效果
`*`代表所有的取值范围内的数字
`/`代表每的意思,`*/5`表示每5个单位
`-`代表从某个数字到某个数字
`,`分开几个离散的数字

举例：
每两个小时输出“have a break now”到test.txt文本中
`0 */2 * * * echo "Have a break now." >> /tmp/test.txt `
晚上11点，早上八点 输出“have a good dream :）”到命令行终端上
`0 23，8 * * * echo "Have a good dream:)" >> /dev/tty1`
每个月的4号和每个礼拜的礼拜一到礼拜三的早上11点执行某段命令
`0 11 4 * 1-3 command line`

**保存cron任务的文件**
所有用户的cron任务（使用crontab命令创建的任务）都被保存在目录“/var/spool/cron/”中的文件中，文件的名称与用户名相同。
例如root用户的cron任务列表文件的名称是“/var/spool/cron/root

**5.4 cron服务的配置文件和目录**

系统任务配置文件
“/etc/crontab”文件中设置的是Linux系统维护所需的任务，一般不需要人为去修改任务脚本目录
在“/etc”目录中有名为cron.hourly 、cron.daily 、cron.weekly 和cron.monthly 的目录,目录中存放的是需要定期执行的系统任务脚本
例如，“/etc/cron.daily/”目录中存放的是每日执行一次的系统任务脚本

# 6.Linux系统网络配置

## 1.网络协议介绍

**1.1 网络协议的概念**
网络协议是网络上所有设备(网络服务器、计算机及交换机、路由器、防火墙等)之间通信规则的集合，它规定了通信时信息必须采用的格式和这些格式的意义。大多数网络都采用分层的体系结构，每一层都建立在它的下层之上，向它的上一层提供一定的服务，而把如何实现这一服务的细节对上一层加以屏蔽。

**1.2 TCP/IP协议**
TCP/IP字面上代表了两个协议：TCP（传输控制协议）和IP（网际协议）。1983年1月1 日，在因特网的前身（ARPA网）中，TCP/IP协议取代了旧的网络控制协议（NCP， Network Control Protocol），从而成为今天的互联网的基石。
![](img/dataStructure/20200521194119.png)

**1.3 常见的网络应用协议**
**HTTP协议**
**超文本传输协议**（HTTP，HyperText Transfer Protocol)：是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。1960年美国人 Ted Nelson构思了一种通过计算机处理文本信息的方法，并称之为超文本（hypertext）,这成为了HTTP超文本传输协议标准架构的发展根基。
**DNS协议**
 DNS是**域名系统**(DomainNameSystem)的缩写，该系统用于命名组织到域层次结构中的计算机和网络服务。域名是由圆点分开一串单词或缩写组成的，每一个域名都对应一个惟一的IP地址，在 Internet上域名与IP地址之间是一一对应的，DNS就是进行域名解析的服务器。 DNS命名用于Internet等TCP/IP网络中，通过用户友好的名称查找计算机和服务。DNS 是因特网的一项核心服务,它作为可以将域名和IP地址相互映射的一个分布式数据库。
**FTP协议**
 FTP(File Transfer Protocol，**文件传输协议**)是 TCP/IP 协议组中的协议之一。 FTP协议包括两个组成部分，其一为FTP服务器，其二为FTP客户端。其中FTP服务器用来存储文件，用户可以使用FTP客户端通过FTP协议访问位于FTP服务器上的资源。在开发网站的时候，通常利用FTP协议把网页或程序传到Web服务器上。此外，由于FTP 传输效率非常高，在网络上传输大的文件时，一般也采用该协议。
**Telnet协议**
**Telnet协议是TCP/IP协议族中的一员，是Internet远程登陆服务的标准协议和主要方式。**它为用户提供了在本地计算机上完成远程主机工作的能力。在终端使用者的电脑上使用telnet程序，用它连接到服务器。终端使用者可以在telnet程序中输入命令，这些命令会在服务器上运行，就像直接在服务器的控制台上输入一样。可以在本地就能控制服务器。要开始一个telnet会话，必须输入用户名和密码来登录服务器。 Telnet是常用的远程控制Web服务器的方法。

## 2.查看Linux网络配置

**2.1 查看网络接口信息**
在Centos7中，要查看网络接口的信息，不再使用ifconfig命令，而是使用了ip命令。 ip命令用来显示或操纵Linux主机的路由、网络设备、策略路由和隧道，是Linux下较新的功能强大的网络配置工具。

ip是iproute2软件包里面的一个强大的网络配置工具，它能够替代一些传统的网络管理工具。
命令格式：
`ip [OPTIONS] OBJECT [COMMAND [ARGUMENTS]]`
常用实例：
`ip link show`			显示设备属性
`ip address show`	显示协议地址

centos7中提供了强大的图形化配置工具，里面有两个命令：nmcli 和nmtui 。
nmcli：NetworkManageCommandLine Interface 
nmtui：NetworkManageTextUser Iterface
**1．通过 nmcli d命令来查看网卡**
**2．通过 nmtui命令可以配置网络**
**3.ip link show命令**
显示出所有可用网络接口的列表（无论接口是否激活）
`ip link show up`：可以查看激活的接口信息。
`ip -s link show`网络接口名称：可以查看更加详细的接口信息。
**4．ip addr命令**
ip addr命令用于获取网卡配置与网络状态等信息。
ip addr命令是`ip address show`命令简写。
使用ip addr命令来查看本机当前的网卡配置与网络状态等信息时，其实主要查看的就是网卡名称、inet参数后面的IP地址、ether参数后面的网卡物理地址（又称为MAC地址)：

**2.2 查看DNS服务器地址**
DNS服务器和域名服务器同义。DNS（Domain Name Server，域名服务器）是进行域名(domain name)和与之相对应的IP地址(IP address)转换的服务器。在Centos 7 上，需要查看DNS服务器地址可以查看/etc/resolv.conf文件内容。

**2.3 查看本机路由表**
使用下面的 route 命令可以查看 Linux 内核路由表。
使用iproute2工具包中的`ip route list`也可以查看路由表的内容

**2.4 查看主机名称**
使用hostname命令可以查看当前系统主机名。
如果需要看更详细的信息，可以使用hostnamectl命令查看主机信息。

## 3.网络配置文件介绍

**3.1 配置文件介绍**
在RHEL或者CentOS等Redhat系的Linux系统里，跟网络有关的主要设置文件如下：

| 位置                           | 文件说明                                        |
| ------------------------------ | ----------------------------------------------- |
| /etc/host.conf                 | 配置域名服务客户端的控制文件                    |
| /etc/hosts                     | 完成主机名映射为IP地址的功能                    |
| /etc/resolv.conf               | 域名服务客户端的配置文件,用于指定域名服务器位置 |
| /etc/sysconfig/network         | 包含了主机最基本的网络信息,用于系统启动.        |
| /etc/sysconfig/network-script/ | 系统启动时初始化网络的一些信息                  |
| /etc/networks                  | 完成域名与网络地址的映射                        |
| /etc/protocols                 | 设定了主机使用的协议以及各个协议的协议号        |
| /etc/services                  | 设定主机的不同端口的网络服务                    |

**3.2 网络接口配置文件介绍**
进入Linux环境中，在/etc/sysconfig/network-scripts/目录中有很多跟网络相关的脚本文件，其中就有网络接口配置文件ifcfg-网络接口名称。
ifcfg-lo是环路地址的配置文件
ifup是开启网络接口的脚本文件
ifdown是关闭网络接口的脚本文件

打开/etc/sysconfig/network-scripts/ifcfg-eno**网络接口配置文件，可以看到里面有许多配置项目。
其他配置项目

| 代码      | 说明                                               |
| --------- | -------------------------------------------------- |
| TYPE      | 设备类型                                           |
| BOOTPROTO | 获取IP地址的方法。static：静态配置，dhcp：dhcp协议 |
| DEVICE    | 表示物理设备的名字                                 |
| IPADDR    | 表示赋给该网卡的IP地址                             |
| NETMASK   | 表示子网掩码                                       |
| GATEWAY=  | 表示默认网关                                       |
| MACADDR=  | 表示指定一个MAC地址                                |
| USERCTL   | 是否允许非root用户控制该设备yes/no                 |
| DNS1      | 表示DNS服务器地址                                  |
| ONBOOT    | 开机启动方式。yes开机启动，no开机不启动            |

**3.3 主机名称配置文件介绍**
/etc/hostname文件中放置的是系统的主机名称，默认情况下Linux环境的主机名称为 localhost.localdomain。

**3.4 地址解析配置文件介绍**
**/etc/host.conf**是用来配置域名服务客户端的控制文件，主要内容如下：
multi on #允许主机拥有多个IP地址
order hosts,bind #主机名解析顺序，即本地解析,DNS域名解析的顺序
这个文件一般不需要我们修改，默认的解析顺序是本地解析,DNS服务器解析。也就是说在本系统里对于一个主机名首先进行本地解析，如果本地解析没有，然后进行DNS服务器解析。

**/etc/hosts**是完成主机名映射为IP地址的具体信息文件，主要内容如下：
127.0.0.1 localhost localhost.localdomain localhost
::1 localhost6.localdomain6 localhost6
可见，默认的情况是本机ip和本机一些主机名的对应关系，第一行是ipv4信息，第二行是ipv6 信息，如果用不上ipv6本机解析，一般把该行注释掉。

**/etc/resolv.conf**是指定域名解析的DNS服务器IP等信息的配置文件,配置参数一般接触到的有4个：
nameserver 指定DNS服务器的IP地址
domain 定义本地域名信息
search 定义域名的搜索列表
sortlist 对gethostbyname返回的地址进行排序
但是最常用的配置参数是nameserver，其他的可以不设置，这个参数指定了DNS服务器的IP 地址，如果设置不正确，就无法进行正常的域名解析。

## 4.临时配置网络信息

**4.1 临时配置IP地址和子网掩码**
使用ip addr 可以查看网络接口的IP地址，也可以临时为网络接口配置一个IP地址和子网掩码，具体格式如下：
`# ip addr add/del IP地址/掩码 [broadcast 广播地址] dev 网络接口名称`
例如：
`# ip addr add 192.168.0.1/24 dev ens33`\#设置ens33网卡IP地址192.168.0.1
`# ip addr del 192.168.0.1/24 dev ens33`\#删除ens33网卡IP地址192.168.0.1
在不重启network网络服务的基础上，临时IP地址和子网掩码是有效的，一旦重启机器或者重启network服务，临时配置的设置会清除。可以给网卡配置多个IP地址。

**4.2 临时配置网关**
在网络中，不同网段通信要通过网关，所以网关的设定也很重要，临时设置网关可以使用如下命令：
`# ip route add/del default via 网关地址 dev 网络接口名称`
配置默认网关：
`# ip route list`#查看路由信息
`# ip route add default via 192.168.0.254 dev eth0`#设置默认网关为192.168.0.254
`# ip route del default `#删除默认路由

配置某网段网关：
`# ip route list`#查看路由信息
`# ip route add 192.168.4.0/24 via 192.168.0.254 dev eth0 `#设置192.168.4.0网段的网关为192.168.0.254,数据走eth0接口
`# ip route del 192.168.4.0/24`#删除192.168.4.0网段的网关

## 5.永久配置网络信息

**5.1 永久配置IP地址等网络信息**
修改网络接口配置文件`/etc/sysconfig/network-scripts/ifcfg-en***`文件内容，可以把 IPV6的部分注释掉。

```python
BOOTPROTO=static #开机协议设置为static
ONBOOT=yes		#设置为开机启动
DNS1=144.144.144.144	#设置主DNS1地址
IPADDR=192.168.2.2		#设置固定的IP地址
NETMASK=255.255.255.0	#设置子网掩码
GATEWAY=192.168.2.1		#网关
```

注意：在Linux环境中，修改了配置文件，一定要重启相关服务才能生效。在修改了网络接口配置文件后，要重启network网络服务。
network网络服务的设置：
`systemctl start network.service`启动network网络服务
`systemctl restart network.service`重启network网络服务
`systemctl stop network.service`停止network网络服务
`systemctl status network.service`查询network网络服务状态
`ifup 网络接口名称`激活指定的网络接口
` ifdown 网络接口名称`禁用指定的网络接口

**5.2 永久配置主机名称**
使用hostnamectl可以查看详细的主机信息，也可以修改主机的名称。使用hostnamectl set-hostname 命令修改主机名，可永久生效。
除了使用命令来修改主机名称以外，还可以直接修改配置文件/etc/hostname.

## 6.网络管理命令

**6.1 网络管理命令介绍**
计算机网络的主要优点是能够实现资源和信息的共享，并且用户可以远程访问信息。Linux 提供了一组强有力的网络命令来为用户服务，这些工具能够帮助用户登录到远程计算机上、传输文件和执行远程命令等。
ping 查询某个机器是否在工作
netstat 查看网络的状况
nslookup 查询域名和IP地址的对应
last命令和lastlog命令查询用户登录信息
traceroute命令用来检测传输的路径

**6.2 ping命令**
**ping命令的全称是Packet Internet Grope，即因特网包探索器**。Ping在网络中使用很广泛，一般用来测试源主机到目的主机网络的连通性。
当网络不通时，一般可以通过该命令来检查和判断网络出现故障的原因。Ping命令通过调用ICMP(因特网控制报文协议），发送一份ICMP回显请求报文给目的主机，并等待返回ICMP回显应答。
命令格式：`ping(选项)(参数)`
常用选项：
-c<完成次数>：设置完成要求回应的次数；
-v：详细显示指令的执行过程。
-s<数据包大小>：设置数据包的大小；
-t<存活数值>：设置存活数值TTL的大小；
注意：在linux环境中，ping命令如果不附加-c选项会一直发数据包进行测试。

**6.3 netstat命令和ss命令**
Netstat是一个监控TCP/IP网络的非常有用的工具，它可以**显示路由表、实际的TCP网络连接，TCP和UDP监听，进程内存管理以及每一个网络接口设备的状态信息**。Netstat用于显示与IP、TCP、UDP和ICMP协议相关的统计数据，一般用于检验本机各端口的网络连接情况，让用户得知有哪些网络连接正在运作。
注意：最小化安装centos7需要安装net-tools软件包才能使用netstat命令。

**netstat命令**
命令格式：`netstat [选项] [参数]`
常用选项：
**-a** (all)显示所有选项，netstat默认不显示LISTEN相关
**-s** 按各个协议进行统计
**-n** 拒绝显示别名，能显示数字的全部转化成数字。
-t (tcp)仅显示tcp相关选项-u (udp)仅显示udp相关选项
-l 仅列出有在 Listen (监听)的服務状态
-p 显示建立相关链接的程序名(macOS中表示协议-p protocol)
-c 每隔一个固定时间，执行该netstat命令。
例子：
显示所有协议内容：`netstat -anp`
列出所有端口: `netstat -a `
列出所有tcp端口: `netstat -at `
列出所有udp端口: `netstat -au `
只显示监听端口: `netstat -l`
只列出所有监听tcp端口: `netstat -lt `
只列出所有监听udp端口: `netstat -lu `
只列出所有监听UNIX端口: `netstat -lx`
显示每个协议的统计信息:`netstat -s `
显示 PID 和进程名称: `netstat -pt `
显示核心路由信息: `netstat -rn`
找出运行在指定端口的进程: `netstat -an | grep “:22”`
显示网络接口列表: `netstat -i`

**ss命令**
ss是Socket Statistics的缩写。ss命令可以用来获取socket统计信息，它可以显示和netstat 类似的内容。但ss的优势在于它能够显示更多更详细的有关TCP和连接状态的信息，而且比 netstat更快速更高效。
命令格式：`ss [参数] [过滤]`
常用选项：
-V, --version 程序版本信息
-o, --options 显示计时器信息
-n, --numeric 不解析服务名称
-e, --extended 显示详细的套接字（sockets）信息
-r, --resolve 解析主机名
-m, --memory 显示套接字（socket）的内存使用情况
-a, --all 显示所有套接字（sockets）
-p, --processes 显示使用套接字（socket）的进程
-t, --tcp 仅显示 TCP套接字（sockets）
-i, --info 显示 TCP内部信息
例子：
显示TCP连接:ss -t -a
列出所有打开的网络连接端口：ss -l
查看进程使用的socket：ss -pl
显示所有UDP Sockets: ss -u -a
匹配远程地址和端口号：ss dst ADDRESS_PATTERN
匹配本地地址和端口号：ss src ADDRESS_PATTERN

**6.4 last命令和lastlog命令**
last命令:查看目前和过去的用户登录信息
lastlog命令:只显示用户最后登录信息

**6.5 traceroute命令**
**traceroute命令用于追踪数据包在网络上的传输时的全部路径**，它默认发送的数据包大小是40字节。通过traceroute我们可以知道信息从你的计算机到互联网另一端的主机是走的什么路径。当然每次数据包由某一同样的出发点（source）到达某一同样的目的地(destination)走的路径可能会不一样，但基本上来说大部分时候所走的路由是相同的。
**语法格式：**`traceroute(选项)(参数)`

